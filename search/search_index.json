{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fundamentos de M\u00e9todos Num\u00e9ricos Este curso pretende ofrecer de forma simple y clara un repaso a algunos de los fundamentos requeridos para cursar asignaturas de m\u00e9todos num\u00e9ricos . Se presentan numerosos ejemplos, siempre ilustrando conceptos relacionados con esta tem\u00e1tica y acompa\u00f1ados con los conocimientos matem\u00e1ticos m\u00ednimos para comprenderlos. Se acompa\u00f1a de una introducci\u00f3n r\u00e1pida a la programaci\u00f3n con el lenguaje C . El objetivo no es presentar una referencia exhaustiva este lenguaje, sino ofrecer la informaci\u00f3n imprescindible para programar los ejemplos y sentar su base para el uso en el futuro de este u otros lenguajes de programaci\u00f3n en m\u00e9todos num\u00e9ricos. \u00bfA qui\u00e9n se dirige este documento? Este documento ha sido realizado pensando en estudiantes de M\u00e9todos Num\u00e9ricos en el Grado en Matem\u00e1ticas de la Universidad de C\u00e1diz, pero est\u00e1 dirigido a toda persona interesada en la tem\u00e1tica. Para profundizar en los m\u00e9todos num\u00e9ricos y en la programaci\u00f3n en lenguaje C, se recomienda consultar bibliograf\u00eda como: Kincaid, D., Cheney, W., An\u00e1lisis Num\u00e9rico. Las matem\u00e1ticas del c\u00e1lculo cient\u00edfico. Addison-Wesley-Iberoamericana 1994 H. Schildt, C. Gu\u00eda de autoense\u00f1anza Osborne/McGraw-Hill, 2002 \u00bfC\u00f3mo puedo utilizar este material? Puedes... acceder al curso a trav\u00e9s de internet o bien descargarlo de este repositorio git . En este caso podr\u00e1s visualizar localmente los ficheros de tipo Markdown situados en el directorio docs , utilizando MkDocs o cualquier visor de Markdown . Deber\u00e1s instalar pymdown-extensions (extensiones Markdwon para Python ) para visualizar expresiones matem\u00e1ticas. El material aqu\u00ed recogido tiene licencia libre, aqu\u00ed puedes leer m\u00e1s la licencia y los autores . \u00bfQu\u00e9 son los M\u00e9todos Num\u00e9ricos? De forma muy gen\u00e9rica, podr\u00edamos definir a los M\u00e9todos Num\u00e9ricos como la rama de las Matem\u00e1ticas que analiza y construye algoritmos para resolver problemas de forma aproximada . Estos algoritmos suelen requerir grandes c\u00e1lculos y son implementados como programas de ordenador y, de hecho, la eclosi\u00f3n de la inform\u00e1tica ha producido un enorme avance en esta rama de las matem\u00e1ticas. Es importante enfatizar que de forma aproximada no significa poco precisa o con poco rigor . De hecho, en m\u00e9todos num\u00e9ricos es fundamental establecer resultados que garanticen el buen planteamiento de los problemas aproximados y la convergencia de las soluciones aproximadas hacia la \u00ab solucion exacta \u00bb del problema considerado. De forma que sea posible el c\u00e1lculo de soluciones aproximadas \u00ab tan cercanas a la soluci\u00f3n exacta como desemos \u00bb, siempre que dispongamos de suficiente potencia de c\u00e1lculo . \u00bfQu\u00e9 es el lenguaje C? El lenguaje de programaci\u00f3n C fue creado por Dennis Ritchie entre 1969 y 1973 cuando trabajaba en Bell Laboratories de AT&T junto con Ken Thompson en el dise\u00f1o del sistema operativo UNIX. C fue creado para poder escribir dicho sistema operativo en un lenguaje de alto nivel, independiente del hardware donde se ejecutara. Contar con un lenguaje de alto nivel permiti\u00f3 el avance de los sistemas operativos, ya que el mismo c\u00f3digo pod\u00eda ser utilizado en las distintas plataformas, propiciando la reutilizaci\u00f3n de c\u00f3digo y reduciendo los tiempos de desarrollo. As\u00ed es que los sistemas operativos basados en UNIX, el sistema BSD, el sistema GNU/Linux y muchos otros fueron desarrollados en C. Con el paso del tiempo, C se ha convertido en el lenguaje m\u00e1s trascendente de la historia de la inform\u00e1tica. Se han desarrollado cientos de bibliotecas que permiten a los programadores de C utilizar el c\u00f3digo desarrollado por otros para la realizaci\u00f3n de tareas comunes. Esto, a su vez, ha propiciado el desarrollo de infinidad de aplicaciones y herramientas en lenguaje C. De forma resumida (m\u00e1s sobre ello a continuaci\u00f3n): C es un lenguaje de alto nivel (cercano al lenguaje humano) aunque posee caracter\u00edsticas de bajo nivel (cercanas al c\u00f3digo de m\u00e1quina ). Es un lenguaje compilado , es decir requiere de un compilador para generar un fichero con c\u00f3digo ejecutable por la m\u00e1quina. Estas caracter\u00edsticas hacen que los programas sean mucho m\u00e1s r\u00e1pidos que en otros lenguajes de mayor nivel como Python o Matlab / Octave : lenguajes interpretados que son usados con frecuencia en c\u00e1lculo num\u00e9rico. Por contra, el tiempo requerido para programar algoritmos en lenguaje C es usualmente mayor que en lenguajes de alto nivel como Python, Matlab/Octave o Mathematica .","title":"Intro"},{"location":"#fundamentos-de-metodos-numericos","text":"Este curso pretende ofrecer de forma simple y clara un repaso a algunos de los fundamentos requeridos para cursar asignaturas de m\u00e9todos num\u00e9ricos . Se presentan numerosos ejemplos, siempre ilustrando conceptos relacionados con esta tem\u00e1tica y acompa\u00f1ados con los conocimientos matem\u00e1ticos m\u00ednimos para comprenderlos. Se acompa\u00f1a de una introducci\u00f3n r\u00e1pida a la programaci\u00f3n con el lenguaje C . El objetivo no es presentar una referencia exhaustiva este lenguaje, sino ofrecer la informaci\u00f3n imprescindible para programar los ejemplos y sentar su base para el uso en el futuro de este u otros lenguajes de programaci\u00f3n en m\u00e9todos num\u00e9ricos.","title":"Fundamentos de M\u00e9todos Num\u00e9ricos"},{"location":"#a-quien-se-dirige-este-documento","text":"Este documento ha sido realizado pensando en estudiantes de M\u00e9todos Num\u00e9ricos en el Grado en Matem\u00e1ticas de la Universidad de C\u00e1diz, pero est\u00e1 dirigido a toda persona interesada en la tem\u00e1tica. Para profundizar en los m\u00e9todos num\u00e9ricos y en la programaci\u00f3n en lenguaje C, se recomienda consultar bibliograf\u00eda como: Kincaid, D., Cheney, W., An\u00e1lisis Num\u00e9rico. Las matem\u00e1ticas del c\u00e1lculo cient\u00edfico. Addison-Wesley-Iberoamericana 1994 H. Schildt, C. Gu\u00eda de autoense\u00f1anza Osborne/McGraw-Hill, 2002","title":"\u00bfA qui\u00e9n se dirige este documento?"},{"location":"#como-puedo-utilizar-este-material","text":"Puedes... acceder al curso a trav\u00e9s de internet o bien descargarlo de este repositorio git . En este caso podr\u00e1s visualizar localmente los ficheros de tipo Markdown situados en el directorio docs , utilizando MkDocs o cualquier visor de Markdown . Deber\u00e1s instalar pymdown-extensions (extensiones Markdwon para Python ) para visualizar expresiones matem\u00e1ticas. El material aqu\u00ed recogido tiene licencia libre, aqu\u00ed puedes leer m\u00e1s la licencia y los autores .","title":"\u00bfC\u00f3mo puedo utilizar este material?"},{"location":"#que-son-los-metodos-numericos","text":"De forma muy gen\u00e9rica, podr\u00edamos definir a los M\u00e9todos Num\u00e9ricos como la rama de las Matem\u00e1ticas que analiza y construye algoritmos para resolver problemas de forma aproximada . Estos algoritmos suelen requerir grandes c\u00e1lculos y son implementados como programas de ordenador y, de hecho, la eclosi\u00f3n de la inform\u00e1tica ha producido un enorme avance en esta rama de las matem\u00e1ticas. Es importante enfatizar que de forma aproximada no significa poco precisa o con poco rigor . De hecho, en m\u00e9todos num\u00e9ricos es fundamental establecer resultados que garanticen el buen planteamiento de los problemas aproximados y la convergencia de las soluciones aproximadas hacia la \u00ab solucion exacta \u00bb del problema considerado. De forma que sea posible el c\u00e1lculo de soluciones aproximadas \u00ab tan cercanas a la soluci\u00f3n exacta como desemos \u00bb, siempre que dispongamos de suficiente potencia de c\u00e1lculo .","title":"\u00bfQu\u00e9 son los M\u00e9todos Num\u00e9ricos?"},{"location":"#que-es-el-lenguaje-c","text":"El lenguaje de programaci\u00f3n C fue creado por Dennis Ritchie entre 1969 y 1973 cuando trabajaba en Bell Laboratories de AT&T junto con Ken Thompson en el dise\u00f1o del sistema operativo UNIX. C fue creado para poder escribir dicho sistema operativo en un lenguaje de alto nivel, independiente del hardware donde se ejecutara. Contar con un lenguaje de alto nivel permiti\u00f3 el avance de los sistemas operativos, ya que el mismo c\u00f3digo pod\u00eda ser utilizado en las distintas plataformas, propiciando la reutilizaci\u00f3n de c\u00f3digo y reduciendo los tiempos de desarrollo. As\u00ed es que los sistemas operativos basados en UNIX, el sistema BSD, el sistema GNU/Linux y muchos otros fueron desarrollados en C. Con el paso del tiempo, C se ha convertido en el lenguaje m\u00e1s trascendente de la historia de la inform\u00e1tica. Se han desarrollado cientos de bibliotecas que permiten a los programadores de C utilizar el c\u00f3digo desarrollado por otros para la realizaci\u00f3n de tareas comunes. Esto, a su vez, ha propiciado el desarrollo de infinidad de aplicaciones y herramientas en lenguaje C. De forma resumida (m\u00e1s sobre ello a continuaci\u00f3n): C es un lenguaje de alto nivel (cercano al lenguaje humano) aunque posee caracter\u00edsticas de bajo nivel (cercanas al c\u00f3digo de m\u00e1quina ). Es un lenguaje compilado , es decir requiere de un compilador para generar un fichero con c\u00f3digo ejecutable por la m\u00e1quina. Estas caracter\u00edsticas hacen que los programas sean mucho m\u00e1s r\u00e1pidos que en otros lenguajes de mayor nivel como Python o Matlab / Octave : lenguajes interpretados que son usados con frecuencia en c\u00e1lculo num\u00e9rico. Por contra, el tiempo requerido para programar algoritmos en lenguaje C es usualmente mayor que en lenguajes de alto nivel como Python, Matlab/Octave o Mathematica .","title":"\u00bfQu\u00e9 es el lenguaje C?"},{"location":"about/","text":"Licencia y autores Copyright \u00a9 J. Rafael Rodr\u00edguez Galv\u00e1n . Copyright \u00a9 Concepci\u00f3n Garc\u00eda V\u00e1zquez . Copyright \u00a9 Antonio N\u00fa\u00f1ez de Alba . Este material tiene licencia libre, en concreto otorga permiso su copia, modificaci\u00f3n o redistribuci\u00f3n bajo los t\u00e9rminos de la Licencia GFDL o de la licencia Creative Commons Compartir-Igual 3.0 . Parte del material aqu\u00ed recogido se basa en el wikilibro \u00ab Programaci\u00f3n en C \u00bb. Publicado por sus autores bajo estas mismas licencias.","title":"M\u00e1s"},{"location":"about/#licencia-y-autores","text":"Copyright \u00a9 J. Rafael Rodr\u00edguez Galv\u00e1n . Copyright \u00a9 Concepci\u00f3n Garc\u00eda V\u00e1zquez . Copyright \u00a9 Antonio N\u00fa\u00f1ez de Alba . Este material tiene licencia libre, en concreto otorga permiso su copia, modificaci\u00f3n o redistribuci\u00f3n bajo los t\u00e9rminos de la Licencia GFDL o de la licencia Creative Commons Compartir-Igual 3.0 . Parte del material aqu\u00ed recogido se basa en el wikilibro \u00ab Programaci\u00f3n en C \u00bb. Publicado por sus autores bajo estas mismas licencias.","title":"Licencia y autores"},{"location":"anexo_1/","text":"Taller 2: Arrancando en C: Distancia y Norma En este taller se exploran los conceptos de distancia eucl\u00eddea y norma sobre el espacio vectorial \\mathbb R^n \\mathbb R^n utilizando programas en lenguaje C. La idea es introducir tanto los conceptos matem\u00e1ticos como inform\u00e1ticos de forma real pero evitando todo lo posible el enredarnos en detalles t\u00e9cnicos, definiciones, demostraciones, etc. Todo ello se entiende que ser\u00e1 objeto de estudio en el futuro. Datos, variables y expresiones aritm\u00e9ticas Los objetos b\u00e1sicos manipulados por un programa C son datos , contenidos en variables . Para actuar sobre estos datos, se utilizan expresiones que contienen operadores que act\u00faan sobre ellos. Cada objeto (datos, variables) tiene un tipo concreto, que determina qu\u00e9 valores puede contener y qu\u00e9 operaciones se pueden realizar sobre \u00e9l. Antes de utilizar una variable, es necesario declararla , especificando cu\u00e1l es su tipo, como veremos a continuaci\u00f3n. A continuaci\u00f3n estudiaremos los tipos de datos m\u00e1s sencillos: enteros, reales y caracteres. M\u00e1s adelante se ver\u00e1n otros tipos de datos m\u00e1s complejos, como los vectores, las cadenas de caracteres y los punteros. Enteros Los enteros son el tipo de dato m\u00e1s primitivo en C. Seg\u00fan el tama\u00f1o de los datos que se quiera almacenar, existen distintos tipos de datos enteros: short , int , long y long long . Aunque el tama\u00f1o de estos tipos datos puede variar seg\u00fan el compilador y la plataforma de hardware (cada uno de estos tipos de datos puede ocupar desde 1 byte hasta 8 bytes en memoria), el tipo de datos int est\u00e1ndar viene dado por 4 4 bytes (es decir, 4\\cdot 8 = 32 4\\cdot 8 = 32 bits). Puedes encontrar m\u00e1s informaci\u00f3n en cualquier gu\u00eda de referencia de C . Adem\u00e1s, el lenguaje C hace la distinci\u00f3n de si el entero es con signo ( signed ) o sin signo ( unsigned ). En caso de que no se declare si es con signo o sin signo, se toma con signo. El rango de valores de un tipo de datos viene dado por su signo y su tama\u00f1o en bytes. Por ejemplo: Un entero sin signo ( unsigned int o simplemente unsigned ) puede almacenar 2^{32}=4294967296 2^{32}=4294967296 valores, comprendidos entre 0 0 y 4294967295 4294967295 . Un entero con signo ( int ) reparte estos 4294967296 4294967296 valores entre -2147483648 -2147483648 y 2147483647 2147483647 . \u00bfQu\u00e9 rango de valores admite un short int est\u00e1ndar, con y sin signo? \u00bfY un long int ? Algunos ejemplos de declaraciones de enteros en C: int p; unsigned int m, n; long q = -10000000; Reales Para representar n\u00fameros reales no enteros se utiliza la sistema de representaci\u00f3n basado en la t\u00e9cnica de coma flotante, que permite operar con n\u00fameros reales de diversas magnitudes, mediante un n\u00famero decimal llamado mantisa y un exponente que indica el orden de magnitud. El tipo de dato flotante en lenguaje C utiliza dos tama\u00f1os: float (simple precisi\u00f3n) double (doble precisi\u00f3n), que ocupan 4 bytes y 8 bytes respectivamente. Puedes consultar informaci\u00f3n concreta sobre el almacenamiento de n\u00fameros en coma flotante, recogida en el est\u00e1ndar IEEE 754-2008 . Comprobar\u00e1s que: #include <stdio.h> int main() { int repetir_test = 1; float x, y; float abs_x, abs_y; while (repetir_test) { /* Leer dos n\u00fameros reales */ printf(\"Introduce un n\u00famero real, x: \"); scanf(\"%f\", &x); printf(\"Introduce un n\u00famero real, y: \"); scanf(\"%f\", &y); /* Calcular el valor absoluto de x */ if(x>0) { abs_x = x; } else { abs_x = -x; } /* Calcular el valor absoluto de y (expresi\u00f3n de if en 1 sola l\u00ednea) */ if(y>0) {abs_y = y;} else {abs_y = -y;} printf(\"Comprobamos que se verifican las propiedades del valor absoluto:\\n\"); /* Comprobar la primera propiedad de valor absoluto */ printf(\" 1) x=%.2f, |x| = %.2f >= 0\", x, abs_x); printf(\" y=%.2f, |y| = %.2f >= 0\\n\", y, abs_y); if (x==0) { printf(\" x es cero (luego tambi\u00e9n |x| es cero)\\n\"); } else { printf(\" x no es cero (luego tampoco |x| lo es)\\n\"); } if (x==0) printf(\" y es cero (luego tambi\u00e9n |y| es cero)\\n\"); else printf(\" y no es cero (luego tampoco |y| lo es)\\n\"); /* Comprobar la segunda propiedad de valor absoluto */ float abs_x_mas_y = x+y > 0? x+y : -(x+y); /* Calcular |x+y| */ printf(\" 2) |x+y| = %.2f es menor o igual que |x|+|y|=%.2f\\n\", abs_x_mas_y, abs_x + abs_y); /* Comprobar la tercera propiedad de valor absoluto */ float abs_x_por_y = x*y > 0? x*y : -(x*y); /* Calcular |x*y| */ printf(\" 3) |x\u00b7y| = %f = |x|\u00b7|y|\\n\", abs_x_por_y); /* Repetir test o terminar */ printf(\"... introduce 0 para terminar o un entero no nulo para repetir: \"); scanf(\"%d\", &repetir_test); } }","title":"Taller 2: Arrancando en C: Distancia y Norma"},{"location":"anexo_1/#taller-2-arrancando-en-c-distancia-y-norma","text":"En este taller se exploran los conceptos de distancia eucl\u00eddea y norma sobre el espacio vectorial \\mathbb R^n \\mathbb R^n utilizando programas en lenguaje C. La idea es introducir tanto los conceptos matem\u00e1ticos como inform\u00e1ticos de forma real pero evitando todo lo posible el enredarnos en detalles t\u00e9cnicos, definiciones, demostraciones, etc. Todo ello se entiende que ser\u00e1 objeto de estudio en el futuro.","title":"Taller 2: Arrancando en C: Distancia y Norma"},{"location":"anexo_1/#datos-variables-y-expresiones-aritmeticas","text":"Los objetos b\u00e1sicos manipulados por un programa C son datos , contenidos en variables . Para actuar sobre estos datos, se utilizan expresiones que contienen operadores que act\u00faan sobre ellos. Cada objeto (datos, variables) tiene un tipo concreto, que determina qu\u00e9 valores puede contener y qu\u00e9 operaciones se pueden realizar sobre \u00e9l. Antes de utilizar una variable, es necesario declararla , especificando cu\u00e1l es su tipo, como veremos a continuaci\u00f3n. A continuaci\u00f3n estudiaremos los tipos de datos m\u00e1s sencillos: enteros, reales y caracteres. M\u00e1s adelante se ver\u00e1n otros tipos de datos m\u00e1s complejos, como los vectores, las cadenas de caracteres y los punteros.","title":"Datos, variables y expresiones aritm\u00e9ticas"},{"location":"anexo_1/#enteros","text":"Los enteros son el tipo de dato m\u00e1s primitivo en C. Seg\u00fan el tama\u00f1o de los datos que se quiera almacenar, existen distintos tipos de datos enteros: short , int , long y long long . Aunque el tama\u00f1o de estos tipos datos puede variar seg\u00fan el compilador y la plataforma de hardware (cada uno de estos tipos de datos puede ocupar desde 1 byte hasta 8 bytes en memoria), el tipo de datos int est\u00e1ndar viene dado por 4 4 bytes (es decir, 4\\cdot 8 = 32 4\\cdot 8 = 32 bits). Puedes encontrar m\u00e1s informaci\u00f3n en cualquier gu\u00eda de referencia de C . Adem\u00e1s, el lenguaje C hace la distinci\u00f3n de si el entero es con signo ( signed ) o sin signo ( unsigned ). En caso de que no se declare si es con signo o sin signo, se toma con signo. El rango de valores de un tipo de datos viene dado por su signo y su tama\u00f1o en bytes. Por ejemplo: Un entero sin signo ( unsigned int o simplemente unsigned ) puede almacenar 2^{32}=4294967296 2^{32}=4294967296 valores, comprendidos entre 0 0 y 4294967295 4294967295 . Un entero con signo ( int ) reparte estos 4294967296 4294967296 valores entre -2147483648 -2147483648 y 2147483647 2147483647 . \u00bfQu\u00e9 rango de valores admite un short int est\u00e1ndar, con y sin signo? \u00bfY un long int ? Algunos ejemplos de declaraciones de enteros en C: int p; unsigned int m, n; long q = -10000000;","title":"Enteros"},{"location":"anexo_1/#reales","text":"Para representar n\u00fameros reales no enteros se utiliza la sistema de representaci\u00f3n basado en la t\u00e9cnica de coma flotante, que permite operar con n\u00fameros reales de diversas magnitudes, mediante un n\u00famero decimal llamado mantisa y un exponente que indica el orden de magnitud. El tipo de dato flotante en lenguaje C utiliza dos tama\u00f1os: float (simple precisi\u00f3n) double (doble precisi\u00f3n), que ocupan 4 bytes y 8 bytes respectivamente. Puedes consultar informaci\u00f3n concreta sobre el almacenamiento de n\u00fameros en coma flotante, recogida en el est\u00e1ndar IEEE 754-2008 . Comprobar\u00e1s que: #include <stdio.h> int main() { int repetir_test = 1; float x, y; float abs_x, abs_y; while (repetir_test) { /* Leer dos n\u00fameros reales */ printf(\"Introduce un n\u00famero real, x: \"); scanf(\"%f\", &x); printf(\"Introduce un n\u00famero real, y: \"); scanf(\"%f\", &y); /* Calcular el valor absoluto de x */ if(x>0) { abs_x = x; } else { abs_x = -x; } /* Calcular el valor absoluto de y (expresi\u00f3n de if en 1 sola l\u00ednea) */ if(y>0) {abs_y = y;} else {abs_y = -y;} printf(\"Comprobamos que se verifican las propiedades del valor absoluto:\\n\"); /* Comprobar la primera propiedad de valor absoluto */ printf(\" 1) x=%.2f, |x| = %.2f >= 0\", x, abs_x); printf(\" y=%.2f, |y| = %.2f >= 0\\n\", y, abs_y); if (x==0) { printf(\" x es cero (luego tambi\u00e9n |x| es cero)\\n\"); } else { printf(\" x no es cero (luego tampoco |x| lo es)\\n\"); } if (x==0) printf(\" y es cero (luego tambi\u00e9n |y| es cero)\\n\"); else printf(\" y no es cero (luego tampoco |y| lo es)\\n\"); /* Comprobar la segunda propiedad de valor absoluto */ float abs_x_mas_y = x+y > 0? x+y : -(x+y); /* Calcular |x+y| */ printf(\" 2) |x+y| = %.2f es menor o igual que |x|+|y|=%.2f\\n\", abs_x_mas_y, abs_x + abs_y); /* Comprobar la tercera propiedad de valor absoluto */ float abs_x_por_y = x*y > 0? x*y : -(x*y); /* Calcular |x*y| */ printf(\" 3) |x\u00b7y| = %f = |x|\u00b7|y|\\n\", abs_x_por_y); /* Repetir test o terminar */ printf(\"... introduce 0 para terminar o un entero no nulo para repetir: \"); scanf(\"%d\", &repetir_test); } }","title":"Reales"},{"location":"ejemplo_Newton_C/","text":"Ejemplo: algoritmo m\u00e9todo de Newton A continuaci\u00f3n escribimos un ejemplo sencillo para ilustrar la implementaci\u00f3n en C del m\u00e9todo de Newton. #include <stdio.h> #include <math.h> double f(double x){ // Aqu\u00ed definiremos la funci\u00f3n con la que queremos trabajar // En este caso: $f(x) = x^4 - x^2 -x$. return pow(x,4)-pow(x,2)-x; } double fDerivada(double x) { // Aqu\u00ed definimos la derivada de la funci\u00f3n anterior return 4*pow(x,3)-2*x-1; } int main(void) { double x; int maximaIteracion; printf(\"PRIMER ACERCAMIENTO A LA PROGRAMACI\u00d3N DEL M\u00c9TODO DE NEWTON\\n\"); printf(\"Introduce una primera aproximaci\u00f3n, $x_0$, del cero de la funci\u00f3n: \"); scanf(\"%lf\",&x); printf(\"Introduce el n\u00famero m\u00e1ximo, $N$, de iteraciones a realizar: \"); scanf(\"%i\",&maximaIteracion); int iter = 0; // M\u00e9todo de Newton while (iter < maximaIteracion) { x = x - f(x)/fDerivada(x); iter++; } printf(\"\\nSoluci\u00f3n aproximada: x = %lf\\n\", x); double y = f(x); printf(\"\\n\u00bfEs f(x)=0?... f(x)=%lf (m\u00e1s exactamente: %.15g)\\n\", y, y); return 0; } \u00bfC\u00f3mo puedo ejecutar este programa? Como se puede ver, el programa utiliza la biblioteca matem\u00e1tica est\u00e1ndar math.h (que contiene funciones como pow , cos , exp , etc). Con el compilador gcc , puedes utilizar la opci\u00f3n -lm para enlazar el programa con esta biblioteca. Si usas el editor Atom y el paquete gpp-compiler , deber\u00e1s acceder a la configuraci\u00f3n de este paquete y, en la opci\u00f3n C Compiler Options , escribir -lm . Si te interesa el uso de la terminal: para compilar el programa basta escribir la orden: gcc -o newton newton.c -lm Por supuesto, la orden anterior supone que el c\u00f3digo est\u00e1 en el fichero newton.c y que te has situado en el directorio que lo contiene ( cd <ruta_al_directorio> ). La orden generar\u00e1 un programa llamado newton , que podr\u00e1s ejecutar en la terminal escribiendo: ./newton \u00bfQu\u00e9 resultados puedo esperar si ejecuto el programa? La funci\u00f3n introducida es un polinomio de grado 4 4 , f(x)=x^4-x^2-x f(x)=x^4-x^2-x , por lo que como m\u00e1ximo tendremos 4 4 ceros. Una de las ra\u00edces (una de las \u00ab soluciones exactas \u00bb de nuestro problema) est\u00e1 clara: x=0 x=0 . El programa te devolver\u00e1 este resultado si la inicializaci\u00f3n es peque\u00f1a en valor absoluto (por ejemplo, x_0=0.5 x_0=0.5 ). Observa c\u00f3mo la aproximaci\u00f3n mejora r\u00e1pidamente cuando aumentas el n\u00famero de iteraciones (por ejemplo, N=1,2,3... N=1,2,3... ) Busca una segunda ra\u00edz: \u00bfqu\u00e9 pasa si tomas inicializaciones positivas? \u00bfy si las tomas negativas? \u00bfCu\u00e1ntas ra\u00edces tiene, aparentemente, la funci\u00f3n? Para saberlo de forma rigurosa, podr\u00edamos recurrir al an\u00e1lisis matem\u00e1tico, crecimiento, decrecimiento, Teorema de Bolzano, etc, pero este no es el tema que ahora nos ocupa. Para esta segunda ra\u00edz, observa que basta una cantidad relativamente peque\u00f1a de iteraciones para obtener f(x) \\simeq 0 f(x) \\simeq 0 con una aproximaci\u00f3n del orden de 10^{-16} 10^{-16} . Y a partir de ese momento, el valor de f(x) f(x) no decrece, por muchas iteraciones que realicemos. El motivo es que el valor 2.22e-16 es el \u00e9psilon de la m\u00e1quina (en doble precisi\u00f3n). En este sentido, 10^{-16} 10^{-16} \u00ab es igual a cero \u00bb en el est\u00e1ndar en coma flotante de doble precisi\u00f3n. Pero, \u00bfpor qu\u00e9 doble precisi\u00f3n? \u00bfqu\u00e9 ocurre si hacemos las cuentas en simple precisi\u00f3n? Haz la prueba: tendr\u00e1s que cambiar el tipo de datos double por float (coma flotante en simple precisi\u00f3n). Tambi\u00e9n el formato lf ( long float ) por f ( float ). \u00bfCoinciden los datos con el \u00e9psilon de la m\u00e1quina en simple precisi\u00f3n , especificado en Wikipedia? Chiste malo : - Por supuesto, las matem\u00e1ticas son una ciencia exacta . - Entonces, 10^{-16}\\neq 0 10^{-16}\\neq 0 . - Depende... \ud83d\ude02","title":"Ejemplo: algoritmo m\u00e9todo de Newton"},{"location":"ejemplo_Newton_C/#ejemplo-algoritmo-metodo-de-newton","text":"A continuaci\u00f3n escribimos un ejemplo sencillo para ilustrar la implementaci\u00f3n en C del m\u00e9todo de Newton. #include <stdio.h> #include <math.h> double f(double x){ // Aqu\u00ed definiremos la funci\u00f3n con la que queremos trabajar // En este caso: $f(x) = x^4 - x^2 -x$. return pow(x,4)-pow(x,2)-x; } double fDerivada(double x) { // Aqu\u00ed definimos la derivada de la funci\u00f3n anterior return 4*pow(x,3)-2*x-1; } int main(void) { double x; int maximaIteracion; printf(\"PRIMER ACERCAMIENTO A LA PROGRAMACI\u00d3N DEL M\u00c9TODO DE NEWTON\\n\"); printf(\"Introduce una primera aproximaci\u00f3n, $x_0$, del cero de la funci\u00f3n: \"); scanf(\"%lf\",&x); printf(\"Introduce el n\u00famero m\u00e1ximo, $N$, de iteraciones a realizar: \"); scanf(\"%i\",&maximaIteracion); int iter = 0; // M\u00e9todo de Newton while (iter < maximaIteracion) { x = x - f(x)/fDerivada(x); iter++; } printf(\"\\nSoluci\u00f3n aproximada: x = %lf\\n\", x); double y = f(x); printf(\"\\n\u00bfEs f(x)=0?... f(x)=%lf (m\u00e1s exactamente: %.15g)\\n\", y, y); return 0; }","title":"Ejemplo: algoritmo m\u00e9todo de Newton"},{"location":"ejemplo_Newton_C/#como-puedo-ejecutar-este-programa","text":"Como se puede ver, el programa utiliza la biblioteca matem\u00e1tica est\u00e1ndar math.h (que contiene funciones como pow , cos , exp , etc). Con el compilador gcc , puedes utilizar la opci\u00f3n -lm para enlazar el programa con esta biblioteca. Si usas el editor Atom y el paquete gpp-compiler , deber\u00e1s acceder a la configuraci\u00f3n de este paquete y, en la opci\u00f3n C Compiler Options , escribir -lm . Si te interesa el uso de la terminal: para compilar el programa basta escribir la orden: gcc -o newton newton.c -lm Por supuesto, la orden anterior supone que el c\u00f3digo est\u00e1 en el fichero newton.c y que te has situado en el directorio que lo contiene ( cd <ruta_al_directorio> ). La orden generar\u00e1 un programa llamado newton , que podr\u00e1s ejecutar en la terminal escribiendo: ./newton","title":"\u00bfC\u00f3mo puedo ejecutar este programa?"},{"location":"ejemplo_Newton_C/#que-resultados-puedo-esperar-si-ejecuto-el-programa","text":"La funci\u00f3n introducida es un polinomio de grado 4 4 , f(x)=x^4-x^2-x f(x)=x^4-x^2-x , por lo que como m\u00e1ximo tendremos 4 4 ceros. Una de las ra\u00edces (una de las \u00ab soluciones exactas \u00bb de nuestro problema) est\u00e1 clara: x=0 x=0 . El programa te devolver\u00e1 este resultado si la inicializaci\u00f3n es peque\u00f1a en valor absoluto (por ejemplo, x_0=0.5 x_0=0.5 ). Observa c\u00f3mo la aproximaci\u00f3n mejora r\u00e1pidamente cuando aumentas el n\u00famero de iteraciones (por ejemplo, N=1,2,3... N=1,2,3... ) Busca una segunda ra\u00edz: \u00bfqu\u00e9 pasa si tomas inicializaciones positivas? \u00bfy si las tomas negativas? \u00bfCu\u00e1ntas ra\u00edces tiene, aparentemente, la funci\u00f3n? Para saberlo de forma rigurosa, podr\u00edamos recurrir al an\u00e1lisis matem\u00e1tico, crecimiento, decrecimiento, Teorema de Bolzano, etc, pero este no es el tema que ahora nos ocupa. Para esta segunda ra\u00edz, observa que basta una cantidad relativamente peque\u00f1a de iteraciones para obtener f(x) \\simeq 0 f(x) \\simeq 0 con una aproximaci\u00f3n del orden de 10^{-16} 10^{-16} . Y a partir de ese momento, el valor de f(x) f(x) no decrece, por muchas iteraciones que realicemos. El motivo es que el valor 2.22e-16 es el \u00e9psilon de la m\u00e1quina (en doble precisi\u00f3n). En este sentido, 10^{-16} 10^{-16} \u00ab es igual a cero \u00bb en el est\u00e1ndar en coma flotante de doble precisi\u00f3n. Pero, \u00bfpor qu\u00e9 doble precisi\u00f3n? \u00bfqu\u00e9 ocurre si hacemos las cuentas en simple precisi\u00f3n? Haz la prueba: tendr\u00e1s que cambiar el tipo de datos double por float (coma flotante en simple precisi\u00f3n). Tambi\u00e9n el formato lf ( long float ) por f ( float ). \u00bfCoinciden los datos con el \u00e9psilon de la m\u00e1quina en simple precisi\u00f3n , especificado en Wikipedia? Chiste malo : - Por supuesto, las matem\u00e1ticas son una ciencia exacta . - Entonces, 10^{-16}\\neq 0 10^{-16}\\neq 0 . - Depende... \ud83d\ude02","title":"\u00bfQu\u00e9 resultados puedo esperar si ejecuto el programa?"},{"location":"taller_1/","text":"Taller 1: Primeros Pasos En esta secci\u00f3n se introducen algunas definiciones sobre conceptos relacionados con los algoritmos num\u00e9ricos y el lenguaje C. Se ofrecen algunas sugerencias para instalar un entorno de desarrollo en C y se introduce un primer ejemplo de este lenguaje. Algoritmos Sin entrar en una definici\u00f3n m\u00e1s precisa, entenderemos por algoritmo a un conjunto de pasos, instrucciones o acciones l\u00f3gicas que se deben seguir para resolver un problema, de forma que: Cada uno de estos pasos est\u00e1 definido sin ambig\u00fcedad. El algoritmo termina un tiempo finito despu\u00e9s de ejecutar todos los pasos. Buena parte de los m\u00e9todos num\u00e9ricos se centra en el desarrollo y an\u00e1lisis matem\u00e1tico de algoritmos para calcular aproximaciones (tan exactas como deseemos) de la soluci\u00f3n de problemas concretos. Ejemplo : Consideremos el siguiente algoritmo (m\u00e9todo de Newton) para aproximar una ra\u00edz o cero de una funci\u00f3n f(x) f(x) , es decir, un n\u00famero \\alpha\\in\\mathbb R \\alpha\\in\\mathbb R tal que f(\\alpha)=0 f(\\alpha)=0 : Leer los datos de entrada: una funci\u00f3n real de una variable, f(x) f(x) , su derivada, f'(x) f'(x) , una estimaci\u00f3n x_0\\in\\mathbb R x_0\\in\\mathbb R , y el n\u00famero m\u00e1ximo de iteraciones, N\\in\\mathbb N N\\in\\mathbb N . Repetir, para cada k\\in\\{0, N-1\\} k\\in\\{0, N-1\\} : $$ x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} $$ Un an\u00e1lisis num\u00e9rico aplicado a este algoritmo nos garantizar\u00e1 que, bajo determinadas hip\u00f3tesis (por ejemplo, f'\\neq0 f'\\neq0 \u00abcerca de \\alpha \\alpha \u00bb) se tiene que x_k \\to \\alpha x_k \\to \\alpha (o sea, \\lim_{k\\to +\\infty} x_k = \\alpha \\lim_{k\\to +\\infty} x_k = \\alpha ). M\u00e1s a\u00fan: para cualquier k\\in\\mathbb N k\\in\\mathbb N , se puede estimar el error o diferencia entre x_k x_k y \\alpha \\alpha (y por supuesto todo ello \u00a1sin saber cu\u00e1l es el valor \\alpha \\alpha , la soluci\u00f3n exacta!). Un programa es una secuencia de instrucciones escritas en un determinado lenguaje de ordenador para realizar o implementar uno o m\u00e1s algoritmos. M\u00e1s adelante, programaremos el algoritmo anterior en lenguaje C , para calcular un cero de una funci\u00f3n concreta. Pero antes de ello, ser\u00e1 necesario realizar una introducci\u00f3n a este lenguaje, a lo que nos dedicamos a continuaci\u00f3n. Nota: quiz\u00e1s ya tengas curiosidad sobre qu\u00e9 pinta tendr\u00eda una implementaci\u00f3n en lenguaje C del algoritmo de Newton : pincha en el enlace para verlo. An\u00edmate a echarle un vistazo, no importa si no lo entiendes todo (es normal). Y en cuanto entiendas el proceso de compilaci\u00f3n y ejecuci\u00f3n de programas C, \u00a1te animamos a experimentar con los resultados! Lenguajes de ordenador El lenguaje de m\u00e1quina consiste en una serie de instrucciones de b\u00e1sicas de control que se almacenan en la memoria del ordenador (como secuencias de d\u00edgitos binarios \\{0,1\\} \\{0,1\\} ) y que la unidad central de procesamiento (la CPU) puede ejecutar directamente . Podr\u00edamos decir que es \u00abel \u00fanico lenguaje que entiende el ordenador\u00bb. Los lenguajes de programaci\u00f3n son el medio de comunicaci\u00f3n entre el programador y una computadora. El programador escribe los algoritmos en alg\u00fan lenguaje de programaci\u00f3n y utiliza las herramientas previstas por ese lenguaje para transformarlo en lenguaje de m\u00e1quina, ejecutable por el ordenador. Adem\u00e1s de etiquetarse seg\u00fan distintos estilos o paradigmas de programaci\u00f3n (imperativa, declarativa, orientada a objetos, etc), los lenguajes de programaci\u00f3n se pueden clasificar como sigue: Alto o bajo nivel Los lenguajes de bajo nivel son aquellos m\u00e1s cercanos al lenguaje m\u00e1quina y por tanto ejercen un control directo sobre el hardware. C es un lenguaje de alto nivel , es decir m\u00e1s cercano al lenguaje humano que el lenguaje m\u00e1quina. Aunque tiene muchas caracter\u00edsticas de lenguaje de bajo nivel (como el uso que permite hacer de la memoria). Estas caracter\u00edsticas hacen que C sea un lenguaje muy potente, ya que permite optimizar al m\u00e1ximo los recursos de la m\u00e1quina. Por ende, esto tambi\u00e9n hace que la dificultad y que los errores que se puedan cometer programando aumenten. As\u00ed, con frecuencia, a C se le considera de nivel medio. Lenguajes de m\u00e1s alto nivel que C son aquellos en los que el programador no necesita encargarse de manipular directamente el s de m\u00e1s alto nivel y a\u00f1ade \u00e9ste capacidades para la orientaci\u00f3n a objetos y otros paradigmas. Otros lenguajes de alto nivel (todos de mayor nivel que C ) muy usados en m\u00e9todos num\u00e9ricos son: Matlab / Octave , Python , Fortran , Julia . Mathematica y R son lenguajes muy usados en matem\u00e1ticas y estad\u00edstica y, con frecuencia, tambi\u00e9n en m\u00e9todos num\u00e9ricos. Otros lenguajes de alto nivel muy utilizados: Java , C# *. Compilados o interpretados Los lenguajes de programaci\u00f3n se pueden tambi\u00e9n clasificar en funci\u00f3n de la forma en que se ejecutan sus \u00f3rdenes. Existen lenguajes que son interpretados , en los que las \u00f3rdenes reflejadas en el c\u00f3digo fuente pasan a trav\u00e9s de un programa (llamado un int\u00e9rprete ) que se encarga de ejecutarlas directamente, en el mismo momento en que est\u00e1n siendo le\u00eddas por el int\u00e9rprete. Lenguaje de este tipo muy usados en el c\u00e1lculo num\u00e9rico son: Matlab / Octave y Python . Por contra, en los lenguajes compilados (como el mismo C , Fortran o, en cierto sentido, Julia ) las \u00f3rdenes descritas en su c\u00f3digo fuente pasan por un proceso de compilaci\u00f3n (transformaci\u00f3n en c\u00f3digo m\u00e1quina por un programa llamado compilador que se almacena en un fichero o archivo ejecutable . Ese archivo puede ejecutarse posteriormente y de forma directa, es decir sin recurrir a un int\u00e9rprete. Ventajas de los lenguajes interpretados : Suelen ser muy portables (entre distintos tipos de ordenadores, siempre que cuenten con un int\u00e9rprete), de programaci\u00f3n m\u00e1s \u00e1gil y de m\u00e1s alto nivel. Ventajas de los lenguajes compilados : suelen tener mayor la velocidad de ejecuci\u00f3n y mayor eficiencia (menor consumo de memoria u otros recursos del ordenador). Y de entre los lenguajes compilados usuales, es com\u00fan considerar a C el de mayor velocidad y menor consumo de recursos, en general. T\u00edpicamente, un algoritmo que debe ser probado y analizado en m\u00e9todos num\u00e9ricos, se desarrollar\u00e1 utilizando un lenguaje interpretado. Si se desea experimentar su potencia o explotarlo como producto final, se desarrollar\u00e1 en un lenguaje compilado. Instalaci\u00f3n de un entorno de desarrollo en C Para empezar a programar, necesitar\u00e1s un entorno de desarrollo que, como m\u00ednimo, conste de un editor para escribir el c\u00f3digo fuente y un compilador para transformarlo en c\u00f3digo m\u00e1quina o ejecutable. Los editores especializados ofrecen la opci\u00f3n de llamar al compilador para realizar el proceso de compilaci\u00f3n y ejecuci\u00f3n del c\u00f3digo. Existen numerosas alternativas con licencia libre como Dev-C++ o Code::Blocks , editores que usualmente se integran con el compilador gcc . Existe otra alternativa, de la que hablaremos a continuaci\u00f3n: el editor Atom y su integraci\u00f3n con gcc . El compilador gcc Este compilador, que es parte de la * colecci\u00f3n de compiladores de GNU (junto a otros como g++ , compilador de C++): Est\u00e1 disponible directamente en los sistemas GNU/Linux . En MacOS se requiere la instalaci\u00f3n de Xcode , disponible directamente en la Mac App Store . En Windows , basta instalar MinGW , un proyecto para portar a plataformas Windows la familia de compiladores de GNU. Para instarlo, basta descargarlo de su p\u00e1gina web . Adem\u00e1s, deber\u00e1s asegurarse de que la carpeta donde se haya instalado el programa gcc haya sido a\u00f1adida a la variable de sistema PATH . Es f\u00e1cil, puedes ver los detalles (por ejemplo) en este tutorial : Atom Atom es un editor de c\u00f3digo fuente disponible con licencia libre para Windows, MacOS, GNU/Linux. Es un editor moderno y con caracter\u00edsticas avanzadas, como el soporte de paquetes (extensiones). Mediante paquetes, Atom soporta pr\u00e1cticamente cualquier lenguaje de programaci\u00f3n conocido. Entre ellos, nos resultar\u00e1 muy \u00fatil el paquete gpp-compiler . Para la instalaci\u00f3n , es suficiente descargar el programa de su p\u00e1gina web y proceder de la forma habitual en cada sistema operativo. Una vez instalado el editor, a\u00f1adimos el paquete gpp-compiler , que permitir\u00e1 iniciar el proceso de compilaci\u00f3n (y ejecuci\u00f3n del programa) directamente desde el editor. Puedes ver los detalles de la instalaci\u00f3n en este tutorial (centrado en Windows, pero generalizable al resto de sistemas operativos): Primer programa en C Con nuestro entorno de desarrollo preparado, podemos escribir nuestro primer programa en C. Es tradicional empezar a aprender un lenguaje de programaci\u00f3n con un ejemplo que imprima en pantalla un mensaje de saludo \u00ab hola mundo \u00bb. #include <stdio.h> int main() { printf(\"Hola mundo!\\n\"); return 0; } Analizaremos brevemente este programa. Es probable que lo primero que salte a la vista sea la l\u00ednea: printf(\"Hola mundo!\\n\"); Esta es la l\u00ednea que hace aparecer la cadena de caracteres Hola Mundo en nuestra pantalla. Notamos que para imprimir algo por pantalla es podemos usar la sentencia (la orden ) printf() escribiendo entre par\u00e9ntesis lo que deseemos imprimir. El utilizar par\u00e9ntesis se debe a que en C, printf es una funci\u00f3n , que imprime su argumento (la cadena Hola Mundo\\n ) en la pantalla. Se denomina invocar o llamar a una funci\u00f3n a la acci\u00f3n de utilizarla para que realice una acci\u00f3n Podemos observar tambi\u00e9n que la cadena a imprimir termina con una extra\u00f1a combinaci\u00f3n: \\n . La combinaci\u00f3n \\n no representa a dos caracteres independientes, sino que a un \u00fanico car\u00e1cter no imprimible: el salto de l\u00ednea. En este caso, se utiliza, despu\u00e9s del texto Hola Mundo se pasar a la siguiente l\u00ednea en la pantalla. Lo \u00faltimo a resaltar es que la l\u00ednea termina con un punto y coma. En C, todas las sentencias terminan con un punto y coma. En el ejemplo, la funci\u00f3n printf es invocada desde de un bloque de c\u00f3digo de la forma: int main() { ... } Las llaves delimitan un bloque, es decir, un grupo de sentencias que se ejecutar\u00e1n de forma secuencial. La l\u00ednea previa int main() indica la definici\u00f3n de una funci\u00f3n, en este caso llamada main . El lenguaje C (y en general en todos los lenguajes de programaci\u00f3n estructurada ) se fundamenta en la definici\u00f3n de funciones que realizan tareas espec\u00edficas. La funci\u00f3n main es especial, porque es el la que se invoca cuando se ejecuta el programa. Observemos ahora la \u00faltima sentencia de la funci\u00f3n main : return 0; Esta orden finaliza la funci\u00f3n main (y, por tanto, finaliza el programa ) y devuelve un valor num\u00e9rico entero (de ah\u00ed la expresi\u00f3n int previa a main ), en este caso 0 0 (que ser\u00e1 interpretado por el sistema operativo para saber que el programa ha funcionado bien, sin fallos). Pues es la definici\u00f3n de una funci\u00f3n, en este caso llamada main. En C (y en general en todos los lenguajes de programaci\u00f3n estructurada) todo se hace a base de funciones, como main y printf. La funci\u00f3n main es especial, porque es el la que se invoca cuando se ejecuta el programa. Todos los programas en C comienzan su ejecuci\u00f3n al principio de la funci\u00f3n main, y cuando \u00e9sta acaba, el programa tambi\u00e9n. Veamos con m\u00e1s detalle la definici\u00f3n de la funci\u00f3n: int main() { ... } El nombre de la funci\u00f3n que viene a continuaci\u00f3n, entre llaves, es main. La funci\u00f3n devuelve como resultado un n\u00famero entero, int (que es el 0 de la instrucci\u00f3n return).[2] Finalmente, centramos la atenci\u00f3n a la l\u00ednea situada al principio del programa, y un tanto aparte (est\u00e1 separada del resto por una l\u00ednea en blanco): #include <stdio.h> Se trata de una instrucci\u00f3n del preprocesador de C, como nos lo indica el s\u00edmbolo # , y lo que hace es incluir en ese punto el contenido del fichero stdio.h que es el que contiene la definici\u00f3n de la funci\u00f3n printf() , que hemos utilizado en nuestro programa. Esta funci\u00f3n, printf() forma parte de la biblioteca est\u00e1ndar de C .","title":"Taller 1"},{"location":"taller_1/#taller-1-primeros-pasos","text":"En esta secci\u00f3n se introducen algunas definiciones sobre conceptos relacionados con los algoritmos num\u00e9ricos y el lenguaje C. Se ofrecen algunas sugerencias para instalar un entorno de desarrollo en C y se introduce un primer ejemplo de este lenguaje.","title":"Taller 1: Primeros Pasos"},{"location":"taller_1/#algoritmos","text":"Sin entrar en una definici\u00f3n m\u00e1s precisa, entenderemos por algoritmo a un conjunto de pasos, instrucciones o acciones l\u00f3gicas que se deben seguir para resolver un problema, de forma que: Cada uno de estos pasos est\u00e1 definido sin ambig\u00fcedad. El algoritmo termina un tiempo finito despu\u00e9s de ejecutar todos los pasos. Buena parte de los m\u00e9todos num\u00e9ricos se centra en el desarrollo y an\u00e1lisis matem\u00e1tico de algoritmos para calcular aproximaciones (tan exactas como deseemos) de la soluci\u00f3n de problemas concretos. Ejemplo : Consideremos el siguiente algoritmo (m\u00e9todo de Newton) para aproximar una ra\u00edz o cero de una funci\u00f3n f(x) f(x) , es decir, un n\u00famero \\alpha\\in\\mathbb R \\alpha\\in\\mathbb R tal que f(\\alpha)=0 f(\\alpha)=0 : Leer los datos de entrada: una funci\u00f3n real de una variable, f(x) f(x) , su derivada, f'(x) f'(x) , una estimaci\u00f3n x_0\\in\\mathbb R x_0\\in\\mathbb R , y el n\u00famero m\u00e1ximo de iteraciones, N\\in\\mathbb N N\\in\\mathbb N . Repetir, para cada k\\in\\{0, N-1\\} k\\in\\{0, N-1\\} : $$ x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} $$ Un an\u00e1lisis num\u00e9rico aplicado a este algoritmo nos garantizar\u00e1 que, bajo determinadas hip\u00f3tesis (por ejemplo, f'\\neq0 f'\\neq0 \u00abcerca de \\alpha \\alpha \u00bb) se tiene que x_k \\to \\alpha x_k \\to \\alpha (o sea, \\lim_{k\\to +\\infty} x_k = \\alpha \\lim_{k\\to +\\infty} x_k = \\alpha ). M\u00e1s a\u00fan: para cualquier k\\in\\mathbb N k\\in\\mathbb N , se puede estimar el error o diferencia entre x_k x_k y \\alpha \\alpha (y por supuesto todo ello \u00a1sin saber cu\u00e1l es el valor \\alpha \\alpha , la soluci\u00f3n exacta!). Un programa es una secuencia de instrucciones escritas en un determinado lenguaje de ordenador para realizar o implementar uno o m\u00e1s algoritmos. M\u00e1s adelante, programaremos el algoritmo anterior en lenguaje C , para calcular un cero de una funci\u00f3n concreta. Pero antes de ello, ser\u00e1 necesario realizar una introducci\u00f3n a este lenguaje, a lo que nos dedicamos a continuaci\u00f3n. Nota: quiz\u00e1s ya tengas curiosidad sobre qu\u00e9 pinta tendr\u00eda una implementaci\u00f3n en lenguaje C del algoritmo de Newton : pincha en el enlace para verlo. An\u00edmate a echarle un vistazo, no importa si no lo entiendes todo (es normal). Y en cuanto entiendas el proceso de compilaci\u00f3n y ejecuci\u00f3n de programas C, \u00a1te animamos a experimentar con los resultados!","title":"Algoritmos"},{"location":"taller_1/#lenguajes-de-ordenador","text":"El lenguaje de m\u00e1quina consiste en una serie de instrucciones de b\u00e1sicas de control que se almacenan en la memoria del ordenador (como secuencias de d\u00edgitos binarios \\{0,1\\} \\{0,1\\} ) y que la unidad central de procesamiento (la CPU) puede ejecutar directamente . Podr\u00edamos decir que es \u00abel \u00fanico lenguaje que entiende el ordenador\u00bb. Los lenguajes de programaci\u00f3n son el medio de comunicaci\u00f3n entre el programador y una computadora. El programador escribe los algoritmos en alg\u00fan lenguaje de programaci\u00f3n y utiliza las herramientas previstas por ese lenguaje para transformarlo en lenguaje de m\u00e1quina, ejecutable por el ordenador. Adem\u00e1s de etiquetarse seg\u00fan distintos estilos o paradigmas de programaci\u00f3n (imperativa, declarativa, orientada a objetos, etc), los lenguajes de programaci\u00f3n se pueden clasificar como sigue:","title":"Lenguajes de ordenador"},{"location":"taller_1/#alto-o-bajo-nivel","text":"Los lenguajes de bajo nivel son aquellos m\u00e1s cercanos al lenguaje m\u00e1quina y por tanto ejercen un control directo sobre el hardware. C es un lenguaje de alto nivel , es decir m\u00e1s cercano al lenguaje humano que el lenguaje m\u00e1quina. Aunque tiene muchas caracter\u00edsticas de lenguaje de bajo nivel (como el uso que permite hacer de la memoria). Estas caracter\u00edsticas hacen que C sea un lenguaje muy potente, ya que permite optimizar al m\u00e1ximo los recursos de la m\u00e1quina. Por ende, esto tambi\u00e9n hace que la dificultad y que los errores que se puedan cometer programando aumenten. As\u00ed, con frecuencia, a C se le considera de nivel medio. Lenguajes de m\u00e1s alto nivel que C son aquellos en los que el programador no necesita encargarse de manipular directamente el s de m\u00e1s alto nivel y a\u00f1ade \u00e9ste capacidades para la orientaci\u00f3n a objetos y otros paradigmas. Otros lenguajes de alto nivel (todos de mayor nivel que C ) muy usados en m\u00e9todos num\u00e9ricos son: Matlab / Octave , Python , Fortran , Julia . Mathematica y R son lenguajes muy usados en matem\u00e1ticas y estad\u00edstica y, con frecuencia, tambi\u00e9n en m\u00e9todos num\u00e9ricos. Otros lenguajes de alto nivel muy utilizados: Java , C# *.","title":"Alto o bajo nivel"},{"location":"taller_1/#compilados-o-interpretados","text":"Los lenguajes de programaci\u00f3n se pueden tambi\u00e9n clasificar en funci\u00f3n de la forma en que se ejecutan sus \u00f3rdenes. Existen lenguajes que son interpretados , en los que las \u00f3rdenes reflejadas en el c\u00f3digo fuente pasan a trav\u00e9s de un programa (llamado un int\u00e9rprete ) que se encarga de ejecutarlas directamente, en el mismo momento en que est\u00e1n siendo le\u00eddas por el int\u00e9rprete. Lenguaje de este tipo muy usados en el c\u00e1lculo num\u00e9rico son: Matlab / Octave y Python . Por contra, en los lenguajes compilados (como el mismo C , Fortran o, en cierto sentido, Julia ) las \u00f3rdenes descritas en su c\u00f3digo fuente pasan por un proceso de compilaci\u00f3n (transformaci\u00f3n en c\u00f3digo m\u00e1quina por un programa llamado compilador que se almacena en un fichero o archivo ejecutable . Ese archivo puede ejecutarse posteriormente y de forma directa, es decir sin recurrir a un int\u00e9rprete. Ventajas de los lenguajes interpretados : Suelen ser muy portables (entre distintos tipos de ordenadores, siempre que cuenten con un int\u00e9rprete), de programaci\u00f3n m\u00e1s \u00e1gil y de m\u00e1s alto nivel. Ventajas de los lenguajes compilados : suelen tener mayor la velocidad de ejecuci\u00f3n y mayor eficiencia (menor consumo de memoria u otros recursos del ordenador). Y de entre los lenguajes compilados usuales, es com\u00fan considerar a C el de mayor velocidad y menor consumo de recursos, en general. T\u00edpicamente, un algoritmo que debe ser probado y analizado en m\u00e9todos num\u00e9ricos, se desarrollar\u00e1 utilizando un lenguaje interpretado. Si se desea experimentar su potencia o explotarlo como producto final, se desarrollar\u00e1 en un lenguaje compilado.","title":"Compilados o interpretados"},{"location":"taller_1/#instalacion-de-un-entorno-de-desarrollo-en-c","text":"Para empezar a programar, necesitar\u00e1s un entorno de desarrollo que, como m\u00ednimo, conste de un editor para escribir el c\u00f3digo fuente y un compilador para transformarlo en c\u00f3digo m\u00e1quina o ejecutable. Los editores especializados ofrecen la opci\u00f3n de llamar al compilador para realizar el proceso de compilaci\u00f3n y ejecuci\u00f3n del c\u00f3digo. Existen numerosas alternativas con licencia libre como Dev-C++ o Code::Blocks , editores que usualmente se integran con el compilador gcc . Existe otra alternativa, de la que hablaremos a continuaci\u00f3n: el editor Atom y su integraci\u00f3n con gcc .","title":"Instalaci\u00f3n de un entorno de desarrollo en C"},{"location":"taller_1/#el-compilador-gcc","text":"Este compilador, que es parte de la * colecci\u00f3n de compiladores de GNU (junto a otros como g++ , compilador de C++): Est\u00e1 disponible directamente en los sistemas GNU/Linux . En MacOS se requiere la instalaci\u00f3n de Xcode , disponible directamente en la Mac App Store . En Windows , basta instalar MinGW , un proyecto para portar a plataformas Windows la familia de compiladores de GNU. Para instarlo, basta descargarlo de su p\u00e1gina web . Adem\u00e1s, deber\u00e1s asegurarse de que la carpeta donde se haya instalado el programa gcc haya sido a\u00f1adida a la variable de sistema PATH . Es f\u00e1cil, puedes ver los detalles (por ejemplo) en este tutorial :","title":"El compilador gcc"},{"location":"taller_1/#atom","text":"Atom es un editor de c\u00f3digo fuente disponible con licencia libre para Windows, MacOS, GNU/Linux. Es un editor moderno y con caracter\u00edsticas avanzadas, como el soporte de paquetes (extensiones). Mediante paquetes, Atom soporta pr\u00e1cticamente cualquier lenguaje de programaci\u00f3n conocido. Entre ellos, nos resultar\u00e1 muy \u00fatil el paquete gpp-compiler . Para la instalaci\u00f3n , es suficiente descargar el programa de su p\u00e1gina web y proceder de la forma habitual en cada sistema operativo. Una vez instalado el editor, a\u00f1adimos el paquete gpp-compiler , que permitir\u00e1 iniciar el proceso de compilaci\u00f3n (y ejecuci\u00f3n del programa) directamente desde el editor. Puedes ver los detalles de la instalaci\u00f3n en este tutorial (centrado en Windows, pero generalizable al resto de sistemas operativos):","title":"Atom"},{"location":"taller_1/#primer-programa-en-c","text":"Con nuestro entorno de desarrollo preparado, podemos escribir nuestro primer programa en C. Es tradicional empezar a aprender un lenguaje de programaci\u00f3n con un ejemplo que imprima en pantalla un mensaje de saludo \u00ab hola mundo \u00bb. #include <stdio.h> int main() { printf(\"Hola mundo!\\n\"); return 0; } Analizaremos brevemente este programa. Es probable que lo primero que salte a la vista sea la l\u00ednea: printf(\"Hola mundo!\\n\"); Esta es la l\u00ednea que hace aparecer la cadena de caracteres Hola Mundo en nuestra pantalla. Notamos que para imprimir algo por pantalla es podemos usar la sentencia (la orden ) printf() escribiendo entre par\u00e9ntesis lo que deseemos imprimir. El utilizar par\u00e9ntesis se debe a que en C, printf es una funci\u00f3n , que imprime su argumento (la cadena Hola Mundo\\n ) en la pantalla. Se denomina invocar o llamar a una funci\u00f3n a la acci\u00f3n de utilizarla para que realice una acci\u00f3n Podemos observar tambi\u00e9n que la cadena a imprimir termina con una extra\u00f1a combinaci\u00f3n: \\n . La combinaci\u00f3n \\n no representa a dos caracteres independientes, sino que a un \u00fanico car\u00e1cter no imprimible: el salto de l\u00ednea. En este caso, se utiliza, despu\u00e9s del texto Hola Mundo se pasar a la siguiente l\u00ednea en la pantalla. Lo \u00faltimo a resaltar es que la l\u00ednea termina con un punto y coma. En C, todas las sentencias terminan con un punto y coma. En el ejemplo, la funci\u00f3n printf es invocada desde de un bloque de c\u00f3digo de la forma: int main() { ... } Las llaves delimitan un bloque, es decir, un grupo de sentencias que se ejecutar\u00e1n de forma secuencial. La l\u00ednea previa int main() indica la definici\u00f3n de una funci\u00f3n, en este caso llamada main . El lenguaje C (y en general en todos los lenguajes de programaci\u00f3n estructurada ) se fundamenta en la definici\u00f3n de funciones que realizan tareas espec\u00edficas. La funci\u00f3n main es especial, porque es el la que se invoca cuando se ejecuta el programa. Observemos ahora la \u00faltima sentencia de la funci\u00f3n main : return 0; Esta orden finaliza la funci\u00f3n main (y, por tanto, finaliza el programa ) y devuelve un valor num\u00e9rico entero (de ah\u00ed la expresi\u00f3n int previa a main ), en este caso 0 0 (que ser\u00e1 interpretado por el sistema operativo para saber que el programa ha funcionado bien, sin fallos). Pues es la definici\u00f3n de una funci\u00f3n, en este caso llamada main. En C (y en general en todos los lenguajes de programaci\u00f3n estructurada) todo se hace a base de funciones, como main y printf. La funci\u00f3n main es especial, porque es el la que se invoca cuando se ejecuta el programa. Todos los programas en C comienzan su ejecuci\u00f3n al principio de la funci\u00f3n main, y cuando \u00e9sta acaba, el programa tambi\u00e9n. Veamos con m\u00e1s detalle la definici\u00f3n de la funci\u00f3n: int main() { ... } El nombre de la funci\u00f3n que viene a continuaci\u00f3n, entre llaves, es main. La funci\u00f3n devuelve como resultado un n\u00famero entero, int (que es el 0 de la instrucci\u00f3n return).[2] Finalmente, centramos la atenci\u00f3n a la l\u00ednea situada al principio del programa, y un tanto aparte (est\u00e1 separada del resto por una l\u00ednea en blanco): #include <stdio.h> Se trata de una instrucci\u00f3n del preprocesador de C, como nos lo indica el s\u00edmbolo # , y lo que hace es incluir en ese punto el contenido del fichero stdio.h que es el que contiene la definici\u00f3n de la funci\u00f3n printf() , que hemos utilizado en nuestro programa. Esta funci\u00f3n, printf() forma parte de la biblioteca est\u00e1ndar de C .","title":"Primer programa en C"},{"location":"taller_2/","text":"Taller 2: Arrancando en C: Valor absoluto y norma En este taller se exploran las propiedades del valor absoluto y se introduce el concepto de norma norma sobre el espacio vectorial \\mathbb R^n \\mathbb R^n utilizando programas en lenguaje C. La idea es introducir tanto los conceptos matem\u00e1ticos como inform\u00e1ticos de forma real pero evitando todo lo posible el enredarnos en detalles t\u00e9cnicos, definiciones, demostraciones, etc. Todo ello se entiende que ser\u00e1 objeto de estudio en el futuro. Valor absoluto Se define el valor absoluto de un n\u00famero real como: |x| = \\left\\{ \\begin{aligned} x &\\mbox{ si } x>0, \\\\ -x &\\mbox{ en otro caso.} \\end{aligned} \\right. |x| = \\left\\{ \\begin{aligned} x &\\mbox{ si } x>0, \\\\ -x &\\mbox{ en otro caso.} \\end{aligned} \\right. En este programa se experimentan las propiedades del valor absoluto: para todo x,y\\in\\mathbb R x,y\\in\\mathbb R , |x| \\ge 0 |x| \\ge 0 , siendo |x|=0 |x|=0 si y solo si x=0 x=0 |x+y| \\le |x|+|y| |x+y| \\le |x|+|y| |x \\; y | = |x| \\cdot |y| |x \\; y | = |x| \\cdot |y| En el programa se introducen numerosas ideas b\u00e1sicas del lenguaje C: variables, comentarios, expresiones aritm\u00e9ticas, bucle while , condicionales, entrada y salida formateadas. Ver los comentarios que aparecen m\u00e1s adelante. #include <stdio.h> int main() { float x, y; float abs_x, abs_y; int repetir_test = 1; while (repetir_test) { /* Leer dos n\u00fameros reales */ printf(\"Introduce un n\u00famero real, x: \"); scanf(\"%f\", &x); printf(\"Introduce un n\u00famero real, y: \"); scanf(\"%f\", &y); /* Calcular el valor absoluto de x */ if(x>0) { abs_x = x; } else { abs_x = -x; } /* Calcular el valor absoluto de y (expresi\u00f3n de if en 1 sola l\u00ednea) */ if(y>0) {abs_y = y;} else {abs_y = -y;} printf(\"Comprobamos que se verifican las propiedades del valor absoluto:\\n\"); /* Comprobar la primera propiedad de valor absoluto */ printf(\" 1) x=%.2f, |x| = %.2f >= 0\", x, abs_x); printf(\" y=%.2f, |y| = %.2f >= 0\\n\", y, abs_y); if (x==0) { printf(\" x es cero (luego tambi\u00e9n |x| lo es)\\n\"); } else { printf(\" x no es cero (luego tampoco |x| lo es)\\n\"); } if (x==0) printf(\" y es cero (luego tambi\u00e9n |y| lo es)\\n\"); else printf(\" y no es cero (luego tampoco |y| lo es)\\n\"); /* Comprobar la segunda propiedad de valor absoluto */ float abs_x_mas_y = x+y > 0? x+y : -(x+y); /* Calcular |x+y| */ printf(\" 2) |x+y| = %.2f es menor o igual que |x|+|y|=%.2f\\n\", abs_x_mas_y, abs_x + abs_y); /* Comprobar la tercera propiedad de valor absoluto */ float abs_x_por_y = x*y > 0? x*y : -(x*y); /* Calcular |x*y| */ printf(\" 3) |x\u00b7y| = %f = |x|\u00b7|y|\\n\", abs_x_por_y); /* Repetir test o terminar */ printf(\"... introduce 0 para terminar o un entero no nulo para repetir: \"); scanf(\"%d\", &repetir_test); } return 0; } Algunos comentarios: El programa consiste en la definici\u00f3n de una funci\u00f3n llamada main , cuyo contenido se especifica en l\u00edneas de c\u00f3digo contenidas entre llaves { }. Cada expresi\u00f3n termina con un punto y coma \\; Las l\u00edneas contenidas entre los s\u00edmbolos /* y */ son comentarios. \u00c9stos son opcionales, es buena idea utilizarlos pero sin abusar de ellos. El programa comienza declarando cinco variables, x , y , etc. En, todas las variables deben ser declaradas antes de utilizarse. Las cuatro primeras son de tipo float (n\u00famero real en coma flotante de simple precisi\u00f3n) y la \u00faltima es int (entero con signo). Existen otros tipos de datos simple como double (coma flotante de doble precisi\u00f3n) o char (car\u00e1cter de 1 byte, 8 bits). El bucle while opera de la siguiente forma: Primero se eval\u00faa la expresi\u00f3n escrita entre par\u00e9ntesis (la variable repetir_test ). Si la condici\u00f3n es verdadera (en este caso, si el entero no es cero), se ejecuta su contenido y al terminar se vuelve a evaluar el condicional. Cuando la condici\u00f3n sea falsa, el bucle termina. La funci\u00f3n scanf lee un car\u00e1cter de la consola de entrada. La expresi\u00f3n de formato \"%f\" indica coma f flotante. El s\u00edmbolo & se utiliza para que la variable que lo sigue pueda recibir su valor dentro de la funci\u00f3n. T\u00e9cnicamente, este s\u00edmbolo indica que el par\u00e1metro se pasa por referencia . Hablaremos m\u00e1s de esto en pr\u00f3ximos talleres. El bucle if eval\u00faa una expresi\u00f3n (entre par\u00e9ntesis). Si es verdadera ejecuta la primera expresi\u00f3n (entre llaves, abs_x = x ). Si es falsa, ejecuta la segunda expresi\u00f3n en este caso abs_x = -x , despu\u00e9s de else . Una expresi\u00f3n puede escribirse varias l\u00edneas o en una sola, como en la l\u00ednea if(y>0) etc. En una expresi\u00f3n de formato como %.2f se indica el n\u00famero de d\u00edgitos que se desea mostrar tras el punto decimal, en este caso 2. Si un bloque de c\u00f3digo consta de una sola expresi\u00f3n, como el segundo if (x==0) , las llaves pueden omitirse. El operador ternario de tipo ? se puede utilizar como substituto de condicionales if . Norma eucl\u00eddea Consideramos ahora el espacio vectorial \\mathbb R^n \\mathbb R^n , donde n=1,2,3... n=1,2,3... . Introduciremos el concepto de norma de un vector \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n , que puede entenderse como una generalizaci\u00f3n del valor absoluto. De hecho, para n=1 n=1 los conceptos de norma y valor absoluto coinciden. En primer lugar: para n=1 n=1 , podemos definir la distancia entre dos n\u00fameros reales como $$ d(x,y)=|x-y|=+\\sqrt{(x-y)^2}. $$ Obviamente, la distancia a cero es d(x,0)=|x| d(x,0)=|x| . En general, para cualquier n\\in\\mathbb N n\\in\\mathbb N , definimos la distancia eucl\u00eddea entre dos puntos \\mathbf x = (x_1,x_2,\\dots, x_n) \\mathbf x = (x_1,x_2,\\dots, x_n) e \\mathbf y=(y_1,y_2,\\dots, y_n) \\mathbf y=(y_1,y_2,\\dots, y_n) como $$ d(\\mathbf x, \\mathbf y) = +\\sqrt{\\sum_{i=1}^n (x_i - y_i)^2}. $$ Por ejemplo, la distancia entre los puntos \\mathbf x=(2,0) \\mathbf x=(2,0) e \\mathbf y=(0,1) \\mathbf y=(0,1) de \\mathbb R^2 \\mathbb R^2 es: $$ d(\\mathbf x, \\mathbf y) = +\\sqrt{(2-0)^2 + (0-1)^2} = +\\sqrt{5} \\simeq 2.2360679 $$ Ahora podemos definir la norma eucl\u00eddea como \u00abla distancia a cero\u00bb o \u00abel m\u00f3dulo\u00bb de un vector. Concretamente, para todo \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n , definimos \\|\\mathbf{x}\\| = +\\sqrt{\\sum_{i=1}^n x_i^2}. \\|\\mathbf{x}\\| = +\\sqrt{\\sum_{i=1}^n x_i^2}. Nota: La norma eucl\u00eddea tambi\u00e9n es conocida como \u00ab norma 2 \u00bb, y se denota \\|\\mathbf{x}\\|_2 \\|\\mathbf{x}\\|_2 , pues consiste en elevar a p=2 p=2 cada coordenada x_i x_i y tomar ra\u00edz p p --\u00e9sima. Puede generalizarse a \\|\\mathbf{x}\\|_p \\|\\mathbf{x}\\|_p para otros valores de p p (no necesariamente p=2 p=2 ). Propiedades de la norma La norma tiene propiedades muy similares al valor absoluto. Para todo \\mathbf x, \\mathbf y\\in\\mathbb R^n \\mathbf x, \\mathbf y\\in\\mathbb R^n , y para todo \\alpha\\in\\mathbb R \\alpha\\in\\mathbb R : \\|\\mathbf x\\| \\ge 0 \\|\\mathbf x\\| \\ge 0 , siendo |\\mathbf x|=0 |\\mathbf x|=0 si y solo si \\mathbf x=0 \\mathbf x=0 \\|\\mathbf x+\\mathbf y\\| \\le \\|\\mathbf x\\|+\\|\\mathbf y\\| \\|\\mathbf x+\\mathbf y\\| \\le \\|\\mathbf x\\|+\\|\\mathbf y\\| \\| \\alpha \\; \\mathbf x \\| = |\\alpha| \\cdot \\|\\mathbf x\\| \\| \\alpha \\; \\mathbf x \\| = |\\alpha| \\cdot \\|\\mathbf x\\| En el siguiente programa se experimenta con estas propiedades en \\mathbb R^2 \\mathbb R^2 : #include <stdio.h> #include <math.h> // Devuelve el valor absoluto de un n\u00famero real, x, en doble precisi\u00f3n double valor_abs(double x) { double result; if(x>=0) { result = x; } else { result = -x; } return result; } // Devuelve la norma eucl\u00eddea de un vector (x1, x2), con argumentos en doble precisi\u00f3n // double norma_euclidea(double x1, double x2) { return sqrt(x1*x1 + x2*x2); } int main() { int repetir_test = 1; double x1, x2; double y1, y2; double a; double norma_x, norma_y; while(repetir_test) { /* Leer dos n\u00fameros reales */ printf(\"Introduce un vector x1 x2 (2 reales separados por espacios): \"); scanf(\"%lf %lf\", &x1, &x2); printf(\"Introduce un vector y1 y2 (2 reales separados por espacios): \"); scanf(\"%lf %lf\", &y1, &y2); norma_x = norma_euclidea(x1, x2); norma_y = norma_euclidea(y1, y2); printf(\"Comprobamos que se verifican las propiedades de la norma:\\n\"); /* Comprobar la primera propiedad de norma */ printf(\" 1) x=(%.2lf,%.2lf), ||x|| = %.3lf >= 0,\", x1, x2, norma_x); printf(\" y=(%.2lf,%.2lf), ||y|| = %.3lf >= 0\\n\", y1, y2, norma_y); if (norma_x==0) { printf(\" ||x|| es cero (luego x es el vector nulo)\\n\"); } else { printf(\" ||x|| no es cero (luego x no es el vector nulo)\\n\"); } if (norma_y==0) { printf(\" ||y|| es cero (luego y es el vector nulo)\\n\"); } else { printf(\" ||y|| no es cero (luego y no es el vector nulo)\\n\"); } /* Comprobar la segunda propiedad de la norma */ printf(\" 2) ||x+y|| = %.3f es menor o igual que ||x|| + ||y|| = %.3f\\n\", norma_euclidea(x1+y1, x2+y2), norma_x + norma_y); /* Comprobar la tercera propiedad de la norma */ printf(\"Introduce un escalar, a (n\u00ba real, doble precisi\u00f3n): \"); scanf(\"%lf\", &a); printf(\" 3) ||a\u00b7x|| = %lf = |a|\u00b7||x|| (= %lf \u00b7 %lf) \\n\", norma_euclidea(a*x1, a*x2), valor_abs(a), norma_euclidea(x1, x2)); /* Repetir test o terminar */ printf(\"... introduce 0 para terminar o un entero no nulo para repetir: \"); scanf(\"%d\", &repetir_test); } return 0; } Algunos comentarios: En el programa hemos definido dos funciones matem\u00e1ticas (antes de ser usadas en la funci\u00f3n main ) para representar, respectivamente, a los concpetos de valor absoluto de un n\u00famero real x x y norma eucl\u00eddea de un vector de \\mathbb R^2 \\mathbb R^2 , (x_1, x_2) (x_1, x_2) . La funci\u00f3n valor_abs toma como par\u00e1metro un n\u00famero real en doble precisi\u00f3n ( double ) y devuelve un n\u00famero del mismo tipo La funci\u00f3n norma_euclidea toma dos par\u00e1metros, x1 y x2 , tambi\u00e9n de tipo coma flotante en doble precisi\u00f3n, y devuelve la norma eucl\u00eddea del vector correspondiente. En el cuerpo de la funci\u00f3n se utiliza la funci\u00f3n sqrt de la biblioteca matem\u00e1tica. Para poder utilizarla, se debe incluir la biblioteca math.h (al principio del programa) y (al menos para el compilador gcc ) el programa debe enlazarse con esta biblioteca, utilizando la opci\u00f3n -lm . Esta opci\u00f3n vendr\u00e1 dada \u00abde serie\u00bb por algunos entornos de compilaci\u00f3n. En otros casos, como con el editor Atom , es probable que debamos especificarlo en la configuraci\u00f3n del paquete correspondiente. Estas funciones se podr\u00edan haber definido despu\u00e9s de main , pero en ese caso deber\u00edan haber sido declaradas en el pre\u00e1mbulo (antes de main ). La forma declarar una funci\u00f3n es: tipo nombre_funci\u00f3n (tipo param1, tipo param2, ...); Es fundamental habituarse a descomponer los programas C en funciones, que funcionar\u00e1n como m\u00f3dulos independientes encargados de realizar tareas espec\u00edficas. La programaci\u00f3n modular es un paradigma de programaci\u00f3n que consiste en dividir un programa en m\u00f3dulos o subprogramas con el fin de hacerlo m\u00e1s legible y manejable. Norma 1 y norma infinito Adem\u00e1s de la eucl\u00eddea, existen dos normas en \\mathbb R^n \\mathbb R^n muy usadas: La norma 1 , definida para cada \\mathbf x = (x_1,\\dots,x_n) \\mathbf x = (x_1,\\dots,x_n) como \\|\\mathbf x\\|_1 = \\sum_{i=1}^n |x_i|. \\|\\mathbf x\\|_1 = \\sum_{i=1}^n |x_i|. La norma infinito , que para cada \\mathbf x = (x_1,\\dots,x_n) \\mathbf x = (x_1,\\dots,x_n) se define como \\|\\mathbf x\\|_\\infty = \\mbox{m\u00e1x} (|x_1|, |x_2|,\\dots, |x_n| ). \\|\\mathbf x\\|_\\infty = \\mbox{m\u00e1x} (|x_1|, |x_2|,\\dots, |x_n| ). Por ejemplo, para el vector \\mathbf x = (2, -3, 1) \\mathbf x = (2, -3, 1) tendremos: \\|\\mathbf x\\|_1 = 6 \\|\\mathbf x\\|_1 = 6 \\|\\mathbf x\\|_2 = +\\sqrt{14} \\simeq 3.74165738 \\|\\mathbf x\\|_2 = +\\sqrt{14} \\simeq 3.74165738 \\|\\mathbf x\\|_\\infty = 3 \\|\\mathbf x\\|_\\infty = 3 Ejercicios: jugando con normas Ejercicio 1 (\u00a1f\u00e1cil!) Modifica el programa anterior, sustituyendo la funci\u00f3n norma_euclidea por otra llamada norma_uno y comprueba con ejemplos que la norma 1 verifica las propiedades de norma enumeradas anteriormente. Repite el proceso definiendo la funci\u00f3n norma_infinito . Para definir estas funciones, te ser\u00e1 \u00fatil utilizar la funci\u00f3n valor_abs . Ejercicio 2 (\u00a1f\u00e1cil!) Realiza un programa que, tras leer un vector \\mathbf x \\in R^3 \\mathbf x \\in R^3 , imprima \\|\\mathbf x\\|_1 \\|\\mathbf x\\|_1 , \\|\\mathbf x\\|_2 \\|\\mathbf x\\|_2 y \\|\\mathbf x\\|_\\infty \\|\\mathbf x\\|_\\infty . Compru\u00e9balo con \\mathbf x = (2, -3, 1) \\mathbf x = (2, -3, 1) y con otros ejemplos. Ejercicio 3 (\u00bfun poco m\u00e1s dif\u00edcil?) Como podr\u00e1s ver en los resultados del programa anterior, siempre se tiene que $$ |\\mathbf x|_\\infty \\le |\\mathbf x|_2 \\le |\\mathbf x|_1. $$ \u00bfPuedes demostrar alguna de estas dos desigualdades? \u00a1Ojo no vale demostrar con ejemplos! En matem\u00e1ticas, una afirmaci\u00f3n no es cierta, por muchos ejemplos que parezcan confirmarla, hasta que es demostrada mediante un razonamiento formal. Ejercicio 4 (\u00a1f\u00e1cil!) Llamamos norma sobre \\mathbb R^n \\mathbb R^n a cualquier aplicaci\u00f3n \\| \\cdot \\|: \\mathbb R^n \\to \\mathbb R^+ \\| \\cdot \\|: \\mathbb R^n \\to \\mathbb R^+ que verifique las propiedades 1, 2 y 3 que fueron enunciadas anteriormente (para la norma eucl\u00eddea). Se dice que dos normas \\|\\cdot\\|_A \\|\\cdot\\|_A y \\|\\cdot\\|_B \\|\\cdot\\|_B son equivalentes si existen dos constantes positivas, C_1 C_1 y C_2 C_2 tales que (para todo \\mathbf x \\mathbf x ) se verifican las dos desigualdades siguientes: \\|\\mathbf x\\|_A \\le C_1 \\, \\|\\mathbf x \\|_B \\|\\mathbf x\\|_A \\le C_1 \\, \\|\\mathbf x \\|_B \\|\\mathbf x\\|_B \\le C_2 \\, \\|\\mathbf x \\|_A \\|\\mathbf x\\|_B \\le C_2 \\, \\|\\mathbf x \\|_A Ya sabemos, por el ejercicio anterior, que \\|\\mathbf x\\|_\\infty \\le C_1 \\|\\mathbf x\\|_2 \\|\\mathbf x\\|_\\infty \\le C_1 \\|\\mathbf x\\|_2 , con C_1=1 C_1=1 . Vamos a experimentar con el ordenador si \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty para alguna constante C_2 C_2 . Para ello, realiza un programa que, tras leer el valor de un vector \\mathbf x = (x_1,x_2)\\in \\mathbb R^2 \\mathbf x = (x_1,x_2)\\in \\mathbb R^2 , imprima: Los valores de \\|\\mathbf x\\|_2 \\|\\mathbf x\\|_2 y \\|\\mathbf x\\|_\\infty \\|\\mathbf x\\|_\\infty El cociente \\frac{\\|\\mathbf x\\|_2} {\\|\\mathbf x\\|_\\infty} \\frac{\\|\\mathbf x\\|_2} {\\|\\mathbf x\\|_\\infty} Prueba con muchos ejemplos. A la vista de ellos, \u00bfpodr\u00edas conjeturar que este cociente siempre (para todo \\mathbf x\\in \\mathbb R^2 \\mathbf x\\in \\mathbb R^2 ) est\u00e1 acotado superiormente por alg\u00fan valor C_2 C_2 ? Si es as\u00ed, \u00a1esa ser\u00eda la constante que estamos buscando! Spoiler al ejercicio anterior Esa constante, C_2 C_2 tal que \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty , s\u00ed que existe. Y estas dos normas son equivalentes en \\mathbb R^n \\mathbb R^n (de hecho, en todo espacio finito-dimensional, aunque \u00a1en espacios de dimensi\u00f3n infinita , esta afirmaci\u00f3n no es cierta! para las normas \\infty \\infty y 2 generalizadas). Tambi\u00e9n la norma 1 es equivalente con las anteriores. De hecho se tiene el siguiente resultado (que se demuestra en el Grado en Matem\u00e1ticas): Teorema Todas las normas en \\mathbb R^n \\mathbb R^n son equivalentes . Eso s\u00ed, el teorema no da los valores de las constantes C_1 C_1 y C_2 C_2 , estos deben calcularse para cada caso particular.","title":"Taller 2"},{"location":"taller_2/#taller-2-arrancando-en-c-valor-absoluto-y-norma","text":"En este taller se exploran las propiedades del valor absoluto y se introduce el concepto de norma norma sobre el espacio vectorial \\mathbb R^n \\mathbb R^n utilizando programas en lenguaje C. La idea es introducir tanto los conceptos matem\u00e1ticos como inform\u00e1ticos de forma real pero evitando todo lo posible el enredarnos en detalles t\u00e9cnicos, definiciones, demostraciones, etc. Todo ello se entiende que ser\u00e1 objeto de estudio en el futuro.","title":"Taller 2: Arrancando en C: Valor absoluto y norma"},{"location":"taller_2/#valor-absoluto","text":"Se define el valor absoluto de un n\u00famero real como: |x| = \\left\\{ \\begin{aligned} x &\\mbox{ si } x>0, \\\\ -x &\\mbox{ en otro caso.} \\end{aligned} \\right. |x| = \\left\\{ \\begin{aligned} x &\\mbox{ si } x>0, \\\\ -x &\\mbox{ en otro caso.} \\end{aligned} \\right. En este programa se experimentan las propiedades del valor absoluto: para todo x,y\\in\\mathbb R x,y\\in\\mathbb R , |x| \\ge 0 |x| \\ge 0 , siendo |x|=0 |x|=0 si y solo si x=0 x=0 |x+y| \\le |x|+|y| |x+y| \\le |x|+|y| |x \\; y | = |x| \\cdot |y| |x \\; y | = |x| \\cdot |y| En el programa se introducen numerosas ideas b\u00e1sicas del lenguaje C: variables, comentarios, expresiones aritm\u00e9ticas, bucle while , condicionales, entrada y salida formateadas. Ver los comentarios que aparecen m\u00e1s adelante. #include <stdio.h> int main() { float x, y; float abs_x, abs_y; int repetir_test = 1; while (repetir_test) { /* Leer dos n\u00fameros reales */ printf(\"Introduce un n\u00famero real, x: \"); scanf(\"%f\", &x); printf(\"Introduce un n\u00famero real, y: \"); scanf(\"%f\", &y); /* Calcular el valor absoluto de x */ if(x>0) { abs_x = x; } else { abs_x = -x; } /* Calcular el valor absoluto de y (expresi\u00f3n de if en 1 sola l\u00ednea) */ if(y>0) {abs_y = y;} else {abs_y = -y;} printf(\"Comprobamos que se verifican las propiedades del valor absoluto:\\n\"); /* Comprobar la primera propiedad de valor absoluto */ printf(\" 1) x=%.2f, |x| = %.2f >= 0\", x, abs_x); printf(\" y=%.2f, |y| = %.2f >= 0\\n\", y, abs_y); if (x==0) { printf(\" x es cero (luego tambi\u00e9n |x| lo es)\\n\"); } else { printf(\" x no es cero (luego tampoco |x| lo es)\\n\"); } if (x==0) printf(\" y es cero (luego tambi\u00e9n |y| lo es)\\n\"); else printf(\" y no es cero (luego tampoco |y| lo es)\\n\"); /* Comprobar la segunda propiedad de valor absoluto */ float abs_x_mas_y = x+y > 0? x+y : -(x+y); /* Calcular |x+y| */ printf(\" 2) |x+y| = %.2f es menor o igual que |x|+|y|=%.2f\\n\", abs_x_mas_y, abs_x + abs_y); /* Comprobar la tercera propiedad de valor absoluto */ float abs_x_por_y = x*y > 0? x*y : -(x*y); /* Calcular |x*y| */ printf(\" 3) |x\u00b7y| = %f = |x|\u00b7|y|\\n\", abs_x_por_y); /* Repetir test o terminar */ printf(\"... introduce 0 para terminar o un entero no nulo para repetir: \"); scanf(\"%d\", &repetir_test); } return 0; }","title":"Valor absoluto"},{"location":"taller_2/#algunos-comentarios","text":"El programa consiste en la definici\u00f3n de una funci\u00f3n llamada main , cuyo contenido se especifica en l\u00edneas de c\u00f3digo contenidas entre llaves { }. Cada expresi\u00f3n termina con un punto y coma \\; Las l\u00edneas contenidas entre los s\u00edmbolos /* y */ son comentarios. \u00c9stos son opcionales, es buena idea utilizarlos pero sin abusar de ellos. El programa comienza declarando cinco variables, x , y , etc. En, todas las variables deben ser declaradas antes de utilizarse. Las cuatro primeras son de tipo float (n\u00famero real en coma flotante de simple precisi\u00f3n) y la \u00faltima es int (entero con signo). Existen otros tipos de datos simple como double (coma flotante de doble precisi\u00f3n) o char (car\u00e1cter de 1 byte, 8 bits). El bucle while opera de la siguiente forma: Primero se eval\u00faa la expresi\u00f3n escrita entre par\u00e9ntesis (la variable repetir_test ). Si la condici\u00f3n es verdadera (en este caso, si el entero no es cero), se ejecuta su contenido y al terminar se vuelve a evaluar el condicional. Cuando la condici\u00f3n sea falsa, el bucle termina. La funci\u00f3n scanf lee un car\u00e1cter de la consola de entrada. La expresi\u00f3n de formato \"%f\" indica coma f flotante. El s\u00edmbolo & se utiliza para que la variable que lo sigue pueda recibir su valor dentro de la funci\u00f3n. T\u00e9cnicamente, este s\u00edmbolo indica que el par\u00e1metro se pasa por referencia . Hablaremos m\u00e1s de esto en pr\u00f3ximos talleres. El bucle if eval\u00faa una expresi\u00f3n (entre par\u00e9ntesis). Si es verdadera ejecuta la primera expresi\u00f3n (entre llaves, abs_x = x ). Si es falsa, ejecuta la segunda expresi\u00f3n en este caso abs_x = -x , despu\u00e9s de else . Una expresi\u00f3n puede escribirse varias l\u00edneas o en una sola, como en la l\u00ednea if(y>0) etc. En una expresi\u00f3n de formato como %.2f se indica el n\u00famero de d\u00edgitos que se desea mostrar tras el punto decimal, en este caso 2. Si un bloque de c\u00f3digo consta de una sola expresi\u00f3n, como el segundo if (x==0) , las llaves pueden omitirse. El operador ternario de tipo ? se puede utilizar como substituto de condicionales if .","title":"Algunos comentarios:"},{"location":"taller_2/#norma-euclidea","text":"Consideramos ahora el espacio vectorial \\mathbb R^n \\mathbb R^n , donde n=1,2,3... n=1,2,3... . Introduciremos el concepto de norma de un vector \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n , que puede entenderse como una generalizaci\u00f3n del valor absoluto. De hecho, para n=1 n=1 los conceptos de norma y valor absoluto coinciden. En primer lugar: para n=1 n=1 , podemos definir la distancia entre dos n\u00fameros reales como $$ d(x,y)=|x-y|=+\\sqrt{(x-y)^2}. $$ Obviamente, la distancia a cero es d(x,0)=|x| d(x,0)=|x| . En general, para cualquier n\\in\\mathbb N n\\in\\mathbb N , definimos la distancia eucl\u00eddea entre dos puntos \\mathbf x = (x_1,x_2,\\dots, x_n) \\mathbf x = (x_1,x_2,\\dots, x_n) e \\mathbf y=(y_1,y_2,\\dots, y_n) \\mathbf y=(y_1,y_2,\\dots, y_n) como $$ d(\\mathbf x, \\mathbf y) = +\\sqrt{\\sum_{i=1}^n (x_i - y_i)^2}. $$ Por ejemplo, la distancia entre los puntos \\mathbf x=(2,0) \\mathbf x=(2,0) e \\mathbf y=(0,1) \\mathbf y=(0,1) de \\mathbb R^2 \\mathbb R^2 es: $$ d(\\mathbf x, \\mathbf y) = +\\sqrt{(2-0)^2 + (0-1)^2} = +\\sqrt{5} \\simeq 2.2360679 $$ Ahora podemos definir la norma eucl\u00eddea como \u00abla distancia a cero\u00bb o \u00abel m\u00f3dulo\u00bb de un vector. Concretamente, para todo \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n \\mathbf x=(x_1,x_2,\\dots, x_n)\\in \\mathbb R^n , definimos \\|\\mathbf{x}\\| = +\\sqrt{\\sum_{i=1}^n x_i^2}. \\|\\mathbf{x}\\| = +\\sqrt{\\sum_{i=1}^n x_i^2}.","title":"Norma eucl\u00eddea"},{"location":"taller_2/#nota","text":"La norma eucl\u00eddea tambi\u00e9n es conocida como \u00ab norma 2 \u00bb, y se denota \\|\\mathbf{x}\\|_2 \\|\\mathbf{x}\\|_2 , pues consiste en elevar a p=2 p=2 cada coordenada x_i x_i y tomar ra\u00edz p p --\u00e9sima. Puede generalizarse a \\|\\mathbf{x}\\|_p \\|\\mathbf{x}\\|_p para otros valores de p p (no necesariamente p=2 p=2 ).","title":"Nota:"},{"location":"taller_2/#propiedades-de-la-norma","text":"La norma tiene propiedades muy similares al valor absoluto. Para todo \\mathbf x, \\mathbf y\\in\\mathbb R^n \\mathbf x, \\mathbf y\\in\\mathbb R^n , y para todo \\alpha\\in\\mathbb R \\alpha\\in\\mathbb R : \\|\\mathbf x\\| \\ge 0 \\|\\mathbf x\\| \\ge 0 , siendo |\\mathbf x|=0 |\\mathbf x|=0 si y solo si \\mathbf x=0 \\mathbf x=0 \\|\\mathbf x+\\mathbf y\\| \\le \\|\\mathbf x\\|+\\|\\mathbf y\\| \\|\\mathbf x+\\mathbf y\\| \\le \\|\\mathbf x\\|+\\|\\mathbf y\\| \\| \\alpha \\; \\mathbf x \\| = |\\alpha| \\cdot \\|\\mathbf x\\| \\| \\alpha \\; \\mathbf x \\| = |\\alpha| \\cdot \\|\\mathbf x\\| En el siguiente programa se experimenta con estas propiedades en \\mathbb R^2 \\mathbb R^2 : #include <stdio.h> #include <math.h> // Devuelve el valor absoluto de un n\u00famero real, x, en doble precisi\u00f3n double valor_abs(double x) { double result; if(x>=0) { result = x; } else { result = -x; } return result; } // Devuelve la norma eucl\u00eddea de un vector (x1, x2), con argumentos en doble precisi\u00f3n // double norma_euclidea(double x1, double x2) { return sqrt(x1*x1 + x2*x2); } int main() { int repetir_test = 1; double x1, x2; double y1, y2; double a; double norma_x, norma_y; while(repetir_test) { /* Leer dos n\u00fameros reales */ printf(\"Introduce un vector x1 x2 (2 reales separados por espacios): \"); scanf(\"%lf %lf\", &x1, &x2); printf(\"Introduce un vector y1 y2 (2 reales separados por espacios): \"); scanf(\"%lf %lf\", &y1, &y2); norma_x = norma_euclidea(x1, x2); norma_y = norma_euclidea(y1, y2); printf(\"Comprobamos que se verifican las propiedades de la norma:\\n\"); /* Comprobar la primera propiedad de norma */ printf(\" 1) x=(%.2lf,%.2lf), ||x|| = %.3lf >= 0,\", x1, x2, norma_x); printf(\" y=(%.2lf,%.2lf), ||y|| = %.3lf >= 0\\n\", y1, y2, norma_y); if (norma_x==0) { printf(\" ||x|| es cero (luego x es el vector nulo)\\n\"); } else { printf(\" ||x|| no es cero (luego x no es el vector nulo)\\n\"); } if (norma_y==0) { printf(\" ||y|| es cero (luego y es el vector nulo)\\n\"); } else { printf(\" ||y|| no es cero (luego y no es el vector nulo)\\n\"); } /* Comprobar la segunda propiedad de la norma */ printf(\" 2) ||x+y|| = %.3f es menor o igual que ||x|| + ||y|| = %.3f\\n\", norma_euclidea(x1+y1, x2+y2), norma_x + norma_y); /* Comprobar la tercera propiedad de la norma */ printf(\"Introduce un escalar, a (n\u00ba real, doble precisi\u00f3n): \"); scanf(\"%lf\", &a); printf(\" 3) ||a\u00b7x|| = %lf = |a|\u00b7||x|| (= %lf \u00b7 %lf) \\n\", norma_euclidea(a*x1, a*x2), valor_abs(a), norma_euclidea(x1, x2)); /* Repetir test o terminar */ printf(\"... introduce 0 para terminar o un entero no nulo para repetir: \"); scanf(\"%d\", &repetir_test); } return 0; }","title":"Propiedades de la norma"},{"location":"taller_2/#algunos-comentarios_1","text":"En el programa hemos definido dos funciones matem\u00e1ticas (antes de ser usadas en la funci\u00f3n main ) para representar, respectivamente, a los concpetos de valor absoluto de un n\u00famero real x x y norma eucl\u00eddea de un vector de \\mathbb R^2 \\mathbb R^2 , (x_1, x_2) (x_1, x_2) . La funci\u00f3n valor_abs toma como par\u00e1metro un n\u00famero real en doble precisi\u00f3n ( double ) y devuelve un n\u00famero del mismo tipo La funci\u00f3n norma_euclidea toma dos par\u00e1metros, x1 y x2 , tambi\u00e9n de tipo coma flotante en doble precisi\u00f3n, y devuelve la norma eucl\u00eddea del vector correspondiente. En el cuerpo de la funci\u00f3n se utiliza la funci\u00f3n sqrt de la biblioteca matem\u00e1tica. Para poder utilizarla, se debe incluir la biblioteca math.h (al principio del programa) y (al menos para el compilador gcc ) el programa debe enlazarse con esta biblioteca, utilizando la opci\u00f3n -lm . Esta opci\u00f3n vendr\u00e1 dada \u00abde serie\u00bb por algunos entornos de compilaci\u00f3n. En otros casos, como con el editor Atom , es probable que debamos especificarlo en la configuraci\u00f3n del paquete correspondiente. Estas funciones se podr\u00edan haber definido despu\u00e9s de main , pero en ese caso deber\u00edan haber sido declaradas en el pre\u00e1mbulo (antes de main ). La forma declarar una funci\u00f3n es: tipo nombre_funci\u00f3n (tipo param1, tipo param2, ...); Es fundamental habituarse a descomponer los programas C en funciones, que funcionar\u00e1n como m\u00f3dulos independientes encargados de realizar tareas espec\u00edficas. La programaci\u00f3n modular es un paradigma de programaci\u00f3n que consiste en dividir un programa en m\u00f3dulos o subprogramas con el fin de hacerlo m\u00e1s legible y manejable.","title":"Algunos comentarios:"},{"location":"taller_2/#norma-1-y-norma-infinito","text":"Adem\u00e1s de la eucl\u00eddea, existen dos normas en \\mathbb R^n \\mathbb R^n muy usadas: La norma 1 , definida para cada \\mathbf x = (x_1,\\dots,x_n) \\mathbf x = (x_1,\\dots,x_n) como \\|\\mathbf x\\|_1 = \\sum_{i=1}^n |x_i|. \\|\\mathbf x\\|_1 = \\sum_{i=1}^n |x_i|. La norma infinito , que para cada \\mathbf x = (x_1,\\dots,x_n) \\mathbf x = (x_1,\\dots,x_n) se define como \\|\\mathbf x\\|_\\infty = \\mbox{m\u00e1x} (|x_1|, |x_2|,\\dots, |x_n| ). \\|\\mathbf x\\|_\\infty = \\mbox{m\u00e1x} (|x_1|, |x_2|,\\dots, |x_n| ). Por ejemplo, para el vector \\mathbf x = (2, -3, 1) \\mathbf x = (2, -3, 1) tendremos: \\|\\mathbf x\\|_1 = 6 \\|\\mathbf x\\|_1 = 6 \\|\\mathbf x\\|_2 = +\\sqrt{14} \\simeq 3.74165738 \\|\\mathbf x\\|_2 = +\\sqrt{14} \\simeq 3.74165738 \\|\\mathbf x\\|_\\infty = 3 \\|\\mathbf x\\|_\\infty = 3","title":"Norma 1 y norma infinito"},{"location":"taller_2/#ejercicios-jugando-con-normas","text":"","title":"Ejercicios: jugando con normas"},{"location":"taller_2/#ejercicio-1-facil","text":"Modifica el programa anterior, sustituyendo la funci\u00f3n norma_euclidea por otra llamada norma_uno y comprueba con ejemplos que la norma 1 verifica las propiedades de norma enumeradas anteriormente. Repite el proceso definiendo la funci\u00f3n norma_infinito . Para definir estas funciones, te ser\u00e1 \u00fatil utilizar la funci\u00f3n valor_abs .","title":"Ejercicio 1 (\u00a1f\u00e1cil!)"},{"location":"taller_2/#ejercicio-2-facil","text":"Realiza un programa que, tras leer un vector \\mathbf x \\in R^3 \\mathbf x \\in R^3 , imprima \\|\\mathbf x\\|_1 \\|\\mathbf x\\|_1 , \\|\\mathbf x\\|_2 \\|\\mathbf x\\|_2 y \\|\\mathbf x\\|_\\infty \\|\\mathbf x\\|_\\infty . Compru\u00e9balo con \\mathbf x = (2, -3, 1) \\mathbf x = (2, -3, 1) y con otros ejemplos.","title":"Ejercicio 2 (\u00a1f\u00e1cil!)"},{"location":"taller_2/#ejercicio-3-un-poco-mas-dificil","text":"Como podr\u00e1s ver en los resultados del programa anterior, siempre se tiene que $$ |\\mathbf x|_\\infty \\le |\\mathbf x|_2 \\le |\\mathbf x|_1. $$ \u00bfPuedes demostrar alguna de estas dos desigualdades? \u00a1Ojo no vale demostrar con ejemplos! En matem\u00e1ticas, una afirmaci\u00f3n no es cierta, por muchos ejemplos que parezcan confirmarla, hasta que es demostrada mediante un razonamiento formal.","title":"Ejercicio 3 (\u00bfun poco m\u00e1s dif\u00edcil?)"},{"location":"taller_2/#ejercicio-4-facil","text":"Llamamos norma sobre \\mathbb R^n \\mathbb R^n a cualquier aplicaci\u00f3n \\| \\cdot \\|: \\mathbb R^n \\to \\mathbb R^+ \\| \\cdot \\|: \\mathbb R^n \\to \\mathbb R^+ que verifique las propiedades 1, 2 y 3 que fueron enunciadas anteriormente (para la norma eucl\u00eddea). Se dice que dos normas \\|\\cdot\\|_A \\|\\cdot\\|_A y \\|\\cdot\\|_B \\|\\cdot\\|_B son equivalentes si existen dos constantes positivas, C_1 C_1 y C_2 C_2 tales que (para todo \\mathbf x \\mathbf x ) se verifican las dos desigualdades siguientes: \\|\\mathbf x\\|_A \\le C_1 \\, \\|\\mathbf x \\|_B \\|\\mathbf x\\|_A \\le C_1 \\, \\|\\mathbf x \\|_B \\|\\mathbf x\\|_B \\le C_2 \\, \\|\\mathbf x \\|_A \\|\\mathbf x\\|_B \\le C_2 \\, \\|\\mathbf x \\|_A Ya sabemos, por el ejercicio anterior, que \\|\\mathbf x\\|_\\infty \\le C_1 \\|\\mathbf x\\|_2 \\|\\mathbf x\\|_\\infty \\le C_1 \\|\\mathbf x\\|_2 , con C_1=1 C_1=1 . Vamos a experimentar con el ordenador si \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty para alguna constante C_2 C_2 . Para ello, realiza un programa que, tras leer el valor de un vector \\mathbf x = (x_1,x_2)\\in \\mathbb R^2 \\mathbf x = (x_1,x_2)\\in \\mathbb R^2 , imprima: Los valores de \\|\\mathbf x\\|_2 \\|\\mathbf x\\|_2 y \\|\\mathbf x\\|_\\infty \\|\\mathbf x\\|_\\infty El cociente \\frac{\\|\\mathbf x\\|_2} {\\|\\mathbf x\\|_\\infty} \\frac{\\|\\mathbf x\\|_2} {\\|\\mathbf x\\|_\\infty} Prueba con muchos ejemplos. A la vista de ellos, \u00bfpodr\u00edas conjeturar que este cociente siempre (para todo \\mathbf x\\in \\mathbb R^2 \\mathbf x\\in \\mathbb R^2 ) est\u00e1 acotado superiormente por alg\u00fan valor C_2 C_2 ? Si es as\u00ed, \u00a1esa ser\u00eda la constante que estamos buscando!","title":"Ejercicio 4 (\u00a1f\u00e1cil!)"},{"location":"taller_2/#spoiler-al-ejercicio-anterior","text":"Esa constante, C_2 C_2 tal que \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty \\|\\mathbf x\\|_2 \\le C_2 \\, \\|\\mathbf x \\|_\\infty , s\u00ed que existe. Y estas dos normas son equivalentes en \\mathbb R^n \\mathbb R^n (de hecho, en todo espacio finito-dimensional, aunque \u00a1en espacios de dimensi\u00f3n infinita , esta afirmaci\u00f3n no es cierta! para las normas \\infty \\infty y 2 generalizadas). Tambi\u00e9n la norma 1 es equivalente con las anteriores. De hecho se tiene el siguiente resultado (que se demuestra en el Grado en Matem\u00e1ticas):","title":"Spoiler al ejercicio anterior"},{"location":"taller_2/#teorema","text":"Todas las normas en \\mathbb R^n \\mathbb R^n son equivalentes . Eso s\u00ed, el teorema no da los valores de las constantes C_1 C_1 y C_2 C_2 , estos deben calcularse para cada caso particular.","title":"Teorema"}]}